%!TEX encoding = UTF-8 Unicode
%!TEX root = ../exercises.tex

\ifPreSolution
\Exercise{\ExeWeekONE}\label{exe:W01}

\begin{Goals}
\input{modules/w01-intro-exercise-goals.tex}
\end{Goals}

\begin{Preparations}
\item \StudyTheory{01}
\item Du behöver en dator med Scala installerad, se appendix~\ref{appendix:compile}.
\end{Preparations}

\fi  %%% END \ifPreSolution

%\let\QUESTBEGIN\empty%\ifPreSolution
%\let\SOLUTION\empty%\else
%\let\QUESTEND\empty%\fi


\BasicTasks
%%%% TODO Strukturera övningen annorlunda: atomer, sammansatta uttryck, funktiner, kojo ??}



\def\what{\emph{Utskrift i Scala REPL.}}

\QUESTBEGIN

\Task \what 

\vspace{1em}\noindent Starta Scala REPL \Eng{Read-Evaluate-Print-Loop}.

\begin{REPLnonum}
$ scala
Welcome to Scala version 2.11.8 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8).
Type in expressions to have them evaluated.
Type :help for more information.

scala> 
\end{REPLnonum}

\Subtask Skriv efter prompten \code{scala>} en sats som skriver ut en valfri hälsningsfras, genom anrop av proceduren \code{println} med något strängargument. Tryck på \textit{Enter} så att satsen kompileras och exekveras. 

\Subtask Skriv samma sats igen (eller tryck pil-upp) men ''glöm bort'' att skriva högerparentesen efter argumentet innan du trycker på \textit{Enter}. Vad händer?

\begin{framed}
\noindent\emph{Tips inför fortsättningen:} Det finns många användbara kortkommandon och andra trix för att jobba snabbt i REPL. Låt gärna någon som kan dessa trix visa dig hur man jobbar snabbare. Läs appendix \ref{appendix:compile:REPL} och prova sedan att kopiera och klistra in text. Använd piltangenterna för att bläddra i historiken och Ctrl+A för att komma till början av raden, Ctrl+K för att radera till slutet av raden, etc.
\end{framed}

\SOLUTION 
\TaskSolved \what

\SubtaskSolved Till exempel:
\begin{REPLnonum}
scala> println("hejsan svejsan")
\end{REPLnonum}

\SubtaskSolved Om högerparentes fattas får man fortsätta skriva på nästa rad. Detta indikeras med vertikalstreck i början av varje ny rad:
\begin{REPLnonum}
scala> println("hejsan svejsan"
     | + "!" 
     | )
hejsan svejsan!
\end{REPLnonum}

\QUESTEND



\def\what{\emph{Konkatenering av strängar.}}

\QUESTBEGIN

\Task \what

\Subtask Skriv ett uttryck som konkatenerar två strängar, t.ex. \code{"gurk"} och \code{"burk"}, med hjälp av operatorn \code{+} och studera resultatet. Vad har uttrycket för värde och typ? Vilken siffra står efter ordet \code{res} i variabeln som lagrar resultatet?

\Subtask Använd resultatet från konkateneringen, t.ex. \code{res0} (byt ev. ut \code{0}:an mot siffran efter \code{res} i utskriften från förra evalueringen), och skriv ett uttryck med hjälp av operatorn \code{*} som upprepar resultatet från förra deluppgiften 42 gånger. 


\SOLUTION

\TaskSolved \what

\SubtaskSolved 
\begin{REPLnonum}
scala> "gurk" + "burk"
res1: String = gurkburk
\end{REPLnonum}
värde: \code{"gurkburk"}, typ:  \code{String}

\SubtaskSolved
\begin{REPLnonum}
scala> res1 * 42
res2: String = gurkatomatgurkatomatgurkatomatgurkatomatgurkatomatgurkatomatgurkatomatgurkatomatgurkatomatgurkatomatgurkatomatgurkatomatgurkatomatgurkatomatgurkatomatgurkatomatgurkatomatgurkatomatgurkatomatgurkatomatgurkatomatgurkatomatgurkatomatgurkatomatgurkatomatgurkatomatgurkatomatgurkatomatgurkatomatgurkatomatgurkatomatgurkatomatgurkatomatgurkatomatgurkatomatgurkatomatgurkatomatgurkatomatgurkatomatgurkatomatgurkatomatgurkatomat
\end{REPLnonum}

\QUESTEND




\def\what{\emph{När upptäcks felet?}}

\QUESTBEGIN

\Task \what 

\Subtask Vad har uttrycket \code{ "hej" * 3 } för typ och värde? Testa i REPL.

\Subtask Byt ut 3:an ovan mot ett så pass stort heltal så att minnet blir fullt. Hur börjar felmeddelandet? Är detta ett körtidsfel eller ett kompileringsfel?

\Subtask Välj ett värde på argumentet efter operatorn \code{*} så att ett typfel genereras. Hur börjar felmeddelandet? Är detta ett körtidsfel eller ett kompileringsfel?

\begin{framed}
\noindent\emph{Tips inför fortsättningen:} Gör gärna fel när du kodar så lär dig mer! Träna på att tolka olika felmeddelanden och fråga någon om hjälp om du inte förstår. Kompilatorns utskrifter kan vara till stor hjälp, men är ibland kryptiska. Om du kör fast och inte kommer vidare själv så be om hjälp, men be om tips snarare än färdiga lösningar så att du behåller initiativet själv och tar kontroll över nästa steg i ditt lärande.
\end{framed}


\SOLUTION

\TaskSolved \what

\SubtaskSolved Typ: \code{String}, värde: \code{"hejhejhej"}

\SubtaskSolved Körtiddsfel:
\begin{REPLnonum}
scala> "hej" * Int.MaxValue
java.lang.OutOfMemoryError: Java heap space
\end{REPLnonum}

\SubtaskSolved Kompileringsfel: (indikeras av texten \code{<console> ... error:})
\begin{REPLnonum}
scala> "hej" * true
<console>:12: error: type mismatch;
 found   : Boolean(true)
 required: Int
       "hej" * true
\end{REPLnonum}


\QUESTEND




\def\what{\emph{Litteraler och typer.}}

\QUESTBEGIN

\Task \what

\Subtask Använd snabbreferensen\footnote{\url{http://cs.lth.se/pgk/quickref/}} för Scala som hjälp för att para ihop nedan litteraler med rätt typ.

\begin{ConceptConnections}[0.35\textwidth]
\Connect{\code|1      |}  {\code|Int    |}
\Connect{\code|1L     |}  {\code|Long   |}
\Connect{\code|1.0    |}  {\code|Double |}
\Connect{\code|1D     |}  {\code|Double |}
\Connect{\code|1F     |}  {\code|Float  |}
\Connect{\code|'1'    |}  {\code|Char   |}
\Connect{\code|\"1\"  |}  {\code|String |}
\Connect{\code|true   |}  {\code|Boolean|} 
\Connect{\code|false  |}  {\code|Boolean|} 
\end{ConceptConnections}

\Subtask Vad är skillnaden mellan typerna \code{Long} och \code{Int}?

\Subtask Vad är skillnaden mellan typerna \code{Double} och \code{Float}?

\Subtask Vad händer om du adderar 1 till det största möjliga värdet av typen \code{Int}?

\SOLUTION

\TaskSolved \what

\SubtaskSolved 

\begin{ConceptConnections}[0\textwidth]
\ConnectSolved{\code|1      |}  {\code|Int    |}
\ConnectSolved{\code|1L     |}  {\code|Long   |}
\ConnectSolved{\code|1.0    |}  {\code|Double |}
\ConnectSolved{\code|1D     |}  {\code|Double |}
\ConnectSolved{\code|1F     |}  {\code|Float  |}
\ConnectSolved{\code|'1'    |}  {\code|Char   |}
\ConnectSolved{\code|\"1\"  |}  {\code|String |}
\ConnectSolved{\code|true   |}  {\code|Boolean|} 
\ConnectSolved{\code|false  |}  {\code|Boolean|} 
\end{ConceptConnections}

\SubtaskSolved Båda är heltal men \code{Long} kan representera större tal än \code{Int}.


\SubtaskSolved Båda är flyttal men \code{Double} har dubbel precision och kan representera större tal med fler decimaler.



\SubtaskSolved Värdet går över gränsen för vad som får plats i 32 bitars heltal och ''börjar om'' på det minsta möjliga heltalet \code{Int.MinValue}

\begin{REPL}
scala> Int.MaxValue + 1
res3: Int = -2147483648

scala> Int.MinValue
res4: Int = -2147483648
\end{REPL}


\QUESTEND









\def\what{\emph{Para ihop begrepp med beskrivning.}}

\QUESTBEGIN

\Task \what

\vspace{1em}\noindent Dra streck mellan det begrepp och den (förenklade) beskrivning som passar bäst:

\begin{ConceptConnections}[0.15\textwidth]
\Connect{litteral}       {anger \emph{ett} specifikt datavärde}
\Connect{sträng}         {en sekvens av tecken}
\Connect{sats}           {en kodrad som \emph{gör} något}
\Connect{uttryck}        {kombinerar värden och funktioner till ett nytt värde}
\Connect{funktion}       {vid anrop med ev. argument beräknas ett returvärde}
\Connect{procedur}       {vid anrop med ev. argument sker (sido)effekt}
\Connect{exekveringsfel} {sker medan programmet kör}
\Connect{kompileringsfel}{sker innan exekveringen startat}
\Connect{abstrahera}     {att införa nya begrepp som förenklar kodningen}
\Connect{kompilera}      {att översätta kod till exekverbar form}
\Connect{typ}            {beskriver vad data kan användas till}
\end{ConceptConnections}

\SOLUTION

\TaskSolved \what

\begin{ConceptConnections}[0\textwidth]
\ConnectSolved{litteral}       {anger \emph{ett} specifikt datavärde}
\ConnectSolved{sträng}         {en sekvens av tecken}
\ConnectSolved{sats}           {en kodrad som \emph{gör} något}
\ConnectSolved{uttryck}        {kombinerar värden och funktioner till ett nytt värde}
\ConnectSolved{funktion}       {vid anrop med ev. argument beräknas ett returvärde}
\ConnectSolved{procedur}       {vid anrop med ev. argument sker (sido)effekt}
\ConnectSolved{exekveringsfel} {sker medan programmet kör}
\ConnectSolved{kompileringsfel}{sker innan exekveringen startat}
\ConnectSolved{abstrahera}     {att införa nya begrepp som förenklar kodningen}
\ConnectSolved{kompilera}      {att översätta kod till exekverbar form}
\ConnectSolved{typ}            {beskriver vad data kan användas till}
\end{ConceptConnections}

\QUESTEND





\clearpage

\ExtraTasks



\def\what{\emph{Typ och värde}}

\QUESTBEGIN

\Task \what~Vilken typ och vilket värde har följande uttryck?  Försök först gissa vilket värde och vilken typ det blir; testa sedan i REPL och notera resultatet.

\Subtask \code{1 + 41}

\Subtask \code{1.0 + 18}

\Subtask \code{42.toDouble}

\Subtask \code{(41 + 1).toDouble}

\Subtask \code{1.042e42}

\Subtask \code{12E6.toLong}

\Subtask \code{"gurk" + 'a'}

\Subtask \code{'A'}

\Subtask \code{'A'.toInt}

\Subtask \linebreak[0] \code{'0'.toInt}

\Subtask \code{'1'.toInt}

\Subtask \code{'9'.toInt}

\Subtask \code{'A' + '0'}

\Subtask \code{('A' + '0').toChar}

\Subtask \code{"*!%#".charAt(0)}

\SOLUTION

\TaskSolved \what

\SubtaskSolved \code{Int, 42}
\SubtaskSolved \code{Double,19}
\SubtaskSolved \code{Double,42}
\SubtaskSolved \code{Double,42}
\SubtaskSolved \code{Double,1.042E42}
\SubtaskSolved \code{Long, 12E6}
\SubtaskSolved \code{String, gurka}
\SubtaskSolved \code{Char, 'A'}
\SubtaskSolved \code{Int,65}
\SubtaskSolved \code{Int,48}
\SubtaskSolved \code{Int,49}
\SubtaskSolved \code{Int,57}
\SubtaskSolved \code{Int, 113}
\SubtaskSolved \code{ Char, 'q'}
\SubtaskSolved \code{ Char, '*'}


\QUESTEND





\def\what{\emph{QUESTTEMPLATE}}

\QUESTBEGIN

\Task \what

\Subtask

\SOLUTION

\TaskSolved \what

\SubtaskSolved 

\QUESTEND




\clearpage

\AdvancedTasks

\def\what{\emph{Flyttalsaritmetik}}

\QUESTBEGIN

\Task \what

\Subtask Vilket är det minsta positiva värdet av typen \code{Double}?

\Subtask Vad är värdet av detta uttryck? Varför blir det så?
\begin{REPL}
scala> Double.MaxValue + Double.MinPositiveValue == Double.MaxValue
\end{REPL}

\SOLUTION

\TaskSolved \what

\SubtaskSolved 

\begin{REPL}
scala> Double.MinPositiveValue
res0: Double = 4.9E-324
\end{REPL}

\SubtaskSolved 

\begin{REPL}
scala> Double.MaxValue + Double.MinPositiveValue == Double.MaxValue
res2: Boolean = true
\end{REPL}

\QUESTEND




\def\what{\emph{QUESTTEMPLATE}}

\QUESTBEGIN

\Task \what

\Subtask

\SOLUTION

\TaskSolved \what

\SubtaskSolved 

\QUESTEND




\section{TODO}

\TODO{SAKERNA NEDAN SKA FLYTTAS/UPPDATERAS/TAS BORT???} 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\ifPreSolution  %%% TODO remove \fi at end of file and break sultions into pieces


\Task\Pen Vad gör dessa satser? Till vad används klammer och semikolon? % uppgift  4
\begin{REPLnonum}
scala> def p = { print("hej"); println("san"); println(42); println("gurka") }
scala> p;p;p;p
\end{REPLnonum}

\Task\Pen Satser versus uttryck. % uppgift 5

\Subtask Vad är det för skillnad på en sats och ett uttryck?

\Subtask Ge exempel på satser som inte är uttryck?

\Subtask Förklara vad som händer för varje evaluerad rad:
\begin{REPL}
scala> def värdeSaknas = ()
scala> värdeSaknas
scala> värdeSaknas.toString
scala> println(värdeSaknas)
scala> println(println("hej"))
\end{REPL}

\Subtask Vilken typ har literalen \code{()}?

\Subtask Vilken returtyp har \code{println}?







\Task \textit{De fyra räknesätten}. Vilket värde och vilken typ har följande uttryck? % uppgift  7

\Subtask \code{42 * 2}

\Subtask \code{42.0 / 2}

\Subtask \code{42 - 0.2}

\Subtask \code{9L + 3d}

\Task \textit{Precedensregler}. Evalueringsordningen kan styras med parenteser. Vilket värde och vilken typ har följande uttryck? % uppgift 8

\Subtask \code{23 + 2 * 2}

\Subtask \code{(23 + 2) * 2}

\Subtask \code{(-(2 - 42)) / (1 + 1 + 1).toDouble}

\Subtask \code{((-(2 - 42)) / (1 + 1 + 1).toDouble).toInt}


\Task \textit{Heltalsdivision}. Vilket värde och vilken typ har uttrycken i deluppgifterna \ref{subtask:divFirst} till \ref{subtask:divLast} nedan? % uppgift 9

\Subtask \label{subtask:divFirst} \code{42 / 2}

\Subtask \code{42 / 4}

\Subtask \code{42.0 / 4}

\Subtask \code{1 / 4}

\Subtask \code{1 % 4}

\Subtask \code{45 % 42}

\Subtask \code{42 % 2}

\Subtask \label{subtask:divLast} \code{41 % 2}

\Subtask\Pen Skriv ett uttryck som ''plockar ut'' siffran \code{7} ur talet \code{5793} med hjälp av heltalsdivision och moduloräkning.


\Task \textit{Heltalsomfång}. För var och en av heltalstyperna i deluppgifterna nedan: undersök i REPL med operationen \code{MaxValue} resp. \code{MinValue}, vad som är största och minsta värde, till exempel \code{Int.MaxValue} etc. % uppgift  10

\Subtask \code{Byte}

\Subtask \code{Short}

\Subtask \code{Int}

\Subtask \code{Long}

\Task Klassen \code{java.lang.Math} och paketobjektet \code{scala.math}. % Uppgift 11
Genom att trycka på tab tagenten kan man se vad som finns i olika paket.

\begin{REPL}
scala> java.    //tryck TAB efter punkten
applet   awt   beans   io   lang   math   net   nio   rmi   security   sql

scala>
\end{REPL}

\Subtask Undersök genom att trycka på Tab-tangenten, vilka funktioner som finns i \code{Math} och \code{math}. Vad heter konstanten $\pi$ i java.lang.Math respektive scala.math?

\begin{REPL}
scala> java.lang.Math.    //tryck TAB efter punkten
scala> scala.math.        //tryck TAB efter punkten
\end{REPL}

\Subtask Undersök dokumentationen för klassen \code{java.lang.Math} här: \\ \url{https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html} \\
Vad gör \code{java.lang.Math.hypot}?

\Subtask Undersök dokumentationen för paketobjektet \code{scala.math} här: \\
\url{http://www.scala-lang.org/api/current/#scala.math.package} \\
Ge exempel på någon funktion i \code{java.lang.Math} som inte finns i \code{scala.math}.

%\TaskSection{Noggrannhet och undantag i aritmetiska uttryck}

\Task Vad händer här? Notera undantag \Eng{exceptions} och noggrannhetsproblem. % Uppgift 12

\Subtask \code{Int.MaxValue} + 1

\Subtask \code{1 / 0}

\Subtask \code{1E8 + 1E-8}

\Subtask \code{1E9 + 1E-9}

\Subtask \code{math.pow(math.hypot(3,6), 2)}

\Subtask \code{1.0 / 0}

\Subtask \code{(1.0 / 0).toInt}

\Subtask \code{math.sqrt(-1)}

\Subtask \code{math.sqrt(Double.NaN)}

\Subtask \code{throw new Exception("PANG!!!")}


\Task \textit{Booleska uttryck}. Vilket värde och vilken typ har följande uttryck?  % Uppgift 13

\Subtask \code{true && true}

\Subtask \code{false && true}

\Subtask \code{true && false}

\Subtask \code{false && false}

\Subtask \code{true || true}

\Subtask \code{false || true}

\Subtask \code{true || false}

\Subtask \code{false || false}

\Subtask \code{42 == 42}

\Subtask \code{42 != 42}

\Subtask \code{42.0001 == 42}

\Subtask \code{42.0000000000000001 == 42}

\Subtask \code{42.0001 > 42}

\Subtask \code{42.0000000000000001 > 42}

\Subtask \code{42.0001 >= 42}

\Subtask \code{42.0000000000000001 <= 42}

\Subtask \code{true == true}

\Subtask \code{true != true}

\Subtask \code{true > false}

\Subtask \code{true < false}

\Subtask \code{'A' == 65}

\Subtask \code{'S' != 66}

\Task\Pen \textit {Variabler och tilldelning}. Rita en ny bild av datorns minne efter varje evaluerad rad nedan. Bilderna ska visa variablers namn, typ och värde.  % Uppgift 14
\begin{REPL}[numbers=left, numberstyle=\color{black}\ttfamily\scriptsize\selectfont]
scala> var a = 13
scala> var b = a + 1
scala> var c = (a + b) * 2.0
scala> b = 0
scala> a = 0
scala> c = c + 1
\end{REPL}
Efter första raden ser minnessituationen ut så här:

\vspace{0.5em}
\begin{tikzpicture}[font=\ttfamily]
\matrix [matrix of nodes, row sep=0, column 2/.style={nodes={rectangle,draw,minimum width=4em}}] (mat)
{
a: Int   &  \makebox(16,12){13}\\
};
\end{tikzpicture}

\Task \textit{Deklarationer: \code{var}, \code{val}, \code{def}}. Evaluera varje rad nedan i tur och ordning i Scala REPL.  % Uppgift 15
\begin{REPL}[numbers=left, numberstyle=\color{black}\ttfamily\scriptsize\selectfont]
scala> var x = 30
scala> x + 1
scala> x
scala> x = x + 1
scala> x
scala> x == x + 1
scala> val y = 20
scala> y = y + 1
scala> var z = {println("gurka"); 10}
scala> def w = {println("gurka"); 10}
scala> z
scala> z
scala> z = z + 1
scala> w
scala> w
scala> w = w + 1
\end{REPL}

\Subtask För varje rad ovan: förklara för vad som händer.

\Subtask Vilka rader ger kompileringsfel och i så fall vilket och varför?

\Subtask\Pen Vad är det för skillnad på \code{var}, \code{val} och \code{def}?

\Subtask\Pen Tilldela variabeln \code{val even } värdet av ett uttryck som med modulo-operatorn \code{%}
och likhetsoperatorn \code{==} testar om ett tal \code{n} är jämnt.

\Subtask\Pen Tilldela variabeln \code{val odd } värdet av ett uttryck som med modulo-operatorn \code{%}
och olikhetsoperatorn \code{!=} testar om ett tal \code{n} är udda.


\Task\Pen \emph{Tilldelningsoperatorer.} Man kan förkorta en tilldelningssats som förändrar en variabel, t.ex. \code{x = x + 1}, genom att använda så kallade tilldelningsoperatorer och skriva \code{x += 1} som betyder samma sak. Rita en ny bild av datorns minne efter varje evaluerad rad nedan. Bilderna ska visa variablers namn, typ och värde.  % Uppgift 16

\begin{REPL}
scala> var a = 40
scala> var b = a + 40
scala> a += 10
scala> b -= 10
scala> a *= 2
scala> b /= 2
\end{REPL}



\Task \emph{Stränginterpolatorn \code{s}.} Man behöver ofta skapa strängar som innehåller variabelvärden. Med ett \code{s} framför en strängliteral får man hjälp av kompilatorn att, på ett typsäkert sätt, infoga variabelvärden i en sträng. Variablernas namn ska föregås med ett dollartecken, t.ex. \code{s"Hej $namn"}.  Om man vill evaluera ett uttryck placeras detta inom klammer direkt efter dollartecknet, t.ex.
\code/s"Dubbla längden: ${namn.size * 2}"/  % Uppgift 17

\begin{REPL}
scala> val f = "Kim"
scala> val e = "Finkodare"
scala> val tot = f.size + e.size
scala> println(s"Namnet '$f $e' har $tot bokstäver.")
scala> println(s"Efternamnet '$e' har ${e.size} bokstäver.")
\end{REPL}

\Subtask Vad skrivs ut ovan?

\Subtask Skapa följande utskrifter med hjälp av stränginterpolatorn \code{s} och lämpliga variabler.
\begin{REPL}
Namnet 'Kim' har 3 bokstäver.
Namnet 'Finkodare' har 9 bokstäver.
\end{REPL}



\Task \code{if}\textit{-sats}.För varje rad nedan; förklara vad som händer.  % Uppgift 18
\begin{REPL}
scala> if (true) println("sant") else println("falskt")
scala> if (false) println("sant") else println("falskt")
scala> if (!true) println("sant") else println("falskt")
scala> if (!false) println("sant") else println("falskt")
scala> def singlaSlant =
scala> 	 if (math.random > 0.5) print(" krona") else print(" klave")
scala> singlaSlant; singlaSlant; singlaSlant
\end{REPL}


\Task \code{if}\textit{-uttryck}. Deklarera följande variabler med nedan initialvärden:  % Uppgift 19

\begin{REPLnonum}
scala> var grönsak = "gurka"
scala> var frukt = "banan"
\end{REPLnonum}

Vad har följande uttryck för värden och typ?

\Subtask \code{if (grönsak == "tomat") "gott" else "inte gott" }

\Subtask \code{if (frukt == "banan") "gott" else "inte gott" }

\Subtask \code{if (frukt.size == grönsak.size) "lika stora" else "olika stora" }

\Subtask \code{if (true) grönsak else frukt }

\Subtask \code{if (false) grönsak else frukt }


\Task \code{for}\textit{-sats}.  Med bakåtpilen \texttt{<-} kan man i en \code{for}-sats ange vilka värden som ska gås igenom i sekvens. Vid varje runda i loopen får en lokal variabel ett nytt värde i sekvensen. % Uppgift 20

\Subtask Vad ger nedan \code{for}-satser för utskrift?

\begin{REPL}
scala> for (i <- 1 to 10) print(i + ", ")
scala> for (i <- 1 until 10) print(i + ", ")
scala> for (i <- 1 to 5) print((i * 2) + ", ")
scala> for (i <- 1 to 92 by 10) print(i + ", ")
scala> for (i <- 10 to 1 by -1) print(i + ", ")
\end{REPL}

\Subtask Skriv en \code{for}-sats som ger följande utskrift:
\begin{REPLnonum}
A1, A4, A7, A10, A13, A16, A19, A22, A25, A28, A31, A34, A37, A40, A43,
\end{REPLnonum}

\Task Repetition med metoden \code{foreach}. Efter framåtpilen \texttt{=>} (se nedan) anges vad som ska hända för varje element som gås igenom sekventiellt. Vid varje runda i loopen får en lokal variabel ett nytt värde i sekvensen.   % Uppgift 21

\Subtask Vad ger nedan satser för utskrifter?

\begin{REPL}
scala> (9 to 19).foreach{i => print(i + ", ")}
scala> (1 until 20).foreach{i => print(i + ", ")}
scala> (0 to 33 by 3).foreach{i => print(i + ", ")}
\end{REPL}

\Subtask Använd \code{foreach} och skriv ut följande:
\begin{REPLnonum}
B33, B30, B27, B24, B21, B18, B15, B12, B9, B6, B3, B0,
\end{REPLnonum}

\Task \code{while}\textit{-sats}. En sats eller ett block med satser upprepas så länge ett villkor är sant.  % Uppgift 22

\Subtask Vad ger nedan satser för utskrifter?
\begin{REPL}
scala> var i = 0
scala> while (i < 10) { println(i); i = i + 1 }
scala> var j = 0; while (j <= 10) { println(j); j = j + 2 }; println(j)
\end{REPL}

\Subtask Skriv en \code{while}-sats som ger följande utskrift. Använd en variabel \code{k} som initialiseras till 1.
\begin{REPLnonum}
A1, A4, A7, A10, A13, A16, A19, A22, A25, A28, A31, A34, A37, A40, A43,
\end{REPLnonum}

\Subtask\Pen Vilken av \code{for}, \code{while} och \code{foreach} är kortast att skriva om man vill repetera mer än en sats 100 gånger? Vilken tycker du är lättast att läsa?

\Task \textit{Slumptal}. Undersök vad dokumentationen säger om funktionen \code{scala.math.random}:\\  % Uppgift 23
\url{http://www.scala-lang.org/api/current/#scala.math.package}

\Subtask\Pen Vilken typ har värdet som returneras av funktionen \code{random}?

\Subtask\Pen Vilket är det minsta respektive största värde som kan returneras?

\Subtask\Pen Är \code{random} en \textit{äkta} funktion \Eng{pure function} i matematisk mening?

\Subtask Anropa funktionen \code{math.random} upprepade gånger och notera vad som händer. Använd pil-upp-tangenten.
\begin{REPLnonum}
scala> math.random
\end{REPLnonum}


\Subtask Vad händer? Använd \textit{pil-upp} och kör nedan \code{for}-sats flera gånger. Förklara vad som sker.

\begin{REPLnonum}
scala> for (i <- 1 to 20) println((math.random * 3 + 1).toInt)
\end{REPLnonum}

\Subtask Skriv en \code{for}-sats som skriver ut 100 slumpmässiga heltal från 0 till och med 9 på var sin rad.

\begin{REPLnonum}
scala> for (i <- 1 to 100) println(???)
\end{REPLnonum}

\Subtask Skriv en \code{for}-sats som skriver ut 100 slumpmässiga heltal från 1 till och med 6 på samma rad.

\begin{REPLnonum}
scala> for (i <- 1 to 100) print(???)
\end{REPLnonum}


\Subtask Använd \textit{pil-upp} och kör nedan \code{while}-sats flera gånger. Förklara vad som sker.

\begin{REPLnonum}
scala> while (math.random > 0.2) println("gurka")
\end{REPLnonum}

\Subtask Ändra i \code{while}-satsen ovan så att sannolikheten ökar att riktigt många strängar ska skrivas ut.

\Subtask Förklara vad som händer nedan.
\begin{REPL}
scala> var slumptal = math.random
scala> while (slumptal > 0.2) { println(slumptal); slumptal = math.random }
\end{REPL}

\Task\Pen \textit{Logik och De Morgans Lagar}. Förenkla följande uttryck. Antag att \code{poäng} och \code{highscore} är heltalsvariabler medan \code{klar} är av typen \code{Boolean}.
  % Uppgift 24

\Subtask \code{poäng > 100 && poäng > 1000}

\Subtask \code{poäng > 100 || poäng > 1000}

\Subtask \code{!(poäng > highscore)}

\Subtask \code{!(poäng > 0 && poäng < highscore) }

\Subtask \code{!(poäng < 0 || poäng > highscore) }

\Subtask \code{klar == true}

\Subtask \code{klar == false}


\clearpage

\ExtraTasks

\Task \textit{Slumptal}.

\Subtask Ersätt \code{???} nedan med literaler så att \code{tärning} returnerar ett slumpmässigt heltal mellan 1 och 6.
\begin{REPLnonum}
scala> def tärning = (math.random * ??? + ???).toInt
\end{REPLnonum}

\Subtask Ersätt \code{???} med literaler så att \code{rnd} blir ett decimaltal med max en decimal mellan 0.0 och 1.0.
\begin{REPLnonum}
scala> def rnd = math.round(math.random * ???) / ???
\end{REPLnonum}

\Subtask Vad blir det för skillnad om \code{math.round} ersätts med \code{math.floor} ovan? (Se dokumentationen av \code{java.lang.Math.round} och \code{java.lang.Math.floor}.)

\Task Undersök vad som finns i paketet \code{scala.math} genom att studera dess dokumentation: \href{http://www.scala-lang.org/api/current/#scala.math.package}{www.scala-lang.org/api/current/\#scala.math.package} och gör några matematiska beräkningar i REPL som använder olika funktioner i \code{math}-paketet.

\Task\Pen Antag att du byter plats mellan satsen efter villkoret och satsen efter \code{else} i \code{if}-satsen nedan. Hur kan du ändra i villkoret så att det ändå skrivs ut samma sak som före bytet?
\begin{Code}
if (x == 42) println("the meaning of it all") else println(":(")
\end{Code}

\Task\Pen Rita en ny bild av datorns minne efter varje evaluerad rad nedan. Bilderna ska visa variablers namn, typ och värde.
\begin{REPL}
scala> var x = 42
scala> var y = x + 1
scala> x += -1
scala> y -= 1
\end{REPL}

\Task Skapa med hjälp av \code{while} några olika oändliga loopar som skriver ut olika saker vid varje loop-runda.

\Task Hitta på några egna övningar för att träna mer på De Morgans lagar.



\clearpage

\AdvancedTasks

\Task Läs om moduloräkning här \href{https://en.wikipedia.org/wiki/Modulo\_operation}{en.wikipedia.org/wiki/Modulo\_operation} och undersök hur det blir med olika tecken (positivt resp. negativt) på divisor och dividend.



\Task Läs om identifierare i Scala och speciellt \emph{literal identifiers} här: \url{http://www.artima.com/pins1ed/functional-objects.html#6.10}.

\Subtask Förklara vad som händer nedan:
\begin{REPLnonum}
scala> val `konstig val` = 42
scala> println(`konstig val`)
\end{REPLnonum}

\Subtask Scala och Java har olika uppsättningar med reserverade ord. På vilket sätt kan ''backticks'' vara använbart med anledning av detta?


\Task Sök upp dokumentationen för \code{java.lang.Integer}.

\Subtask Undersök i REPL hur metoderna \code{toBinaryString} och \code{toHexString} fungerar.

\Subtask Vad betyder literalen \code{0x2a}?

\Task Typannoteringar skapas genom att i ett uttryck placera ett kolon följt av en typ, vid behov  omslutet av en parentes. Skapa ett större uttryck med typannoteringar och försök få kompilatorn att kontrollera typen på intressanta ställen. Märk att typannoteringar också ibland kan användas för att konvertera mellan numeriska typer.


\Task Förklara vad som händer nedan:
\begin{REPL}
scala> var i = 42
scala> i += 1
scala> i *= 2
scala> i /= 3
\end{REPL}


\Task Läs om BigInt och BigDecimal här: \href{http://alvinalexander.com/scala/how-to-use-large-integer-decimal-numbers-in-scala-bigint-bigdecimal}{alvinalexander.com/scala/how-to-use-large-integer-decimal-numbers-in-scala-bigint-bigdecimal} och prova att skapa riktigt stora tal med hjälp av metoden \code{pow} på BigInt och tal med riktigt många decimaler med BigDecimal dess metod \code{pow}.

\Task Sök upp dokumentationtionen för \code{java.lang.Math.multiplyExact} och läs om vad den metoden gör.

\Subtask Vad händer här?
\begin{REPLnonum}
scala> Math.multiplyExact(2, 42)
scala> Math.multiplyExact(Int.MaxValue, Int.MaxValue)
\end{REPLnonum}

\Subtask\Pen Varför kan man vilja använda \code{java.lang.Math.multiplyExact} i stället för ''vanlig'' multiplikation?



\Subtask\Pen Sök med Ctrl+F i webbläsaren och efter förekomster av texten \textit{''overflow''} i javadoc för klassen \code{java.lang.Math} i JDK 8. Vad är ''overflow''? Vilka metoder finns i \code{java.lang.Math} som hjälper dig att upptäcka om det blir overflow?

\Task Använda Scala REPL för att undersöka konstanterna nedan. Vilket av dessa värden är negativt? Vad kan man ha för praktisk nytta av dessa värden i ett program som gör flyttalsberäkningar?

\Subtask \code{java.lang.Double.MIN_VALUE}

\Subtask \code{scala.Double.MinValue}

\Subtask \code{scala.Double.MinPositiveValue}

\Task För typerna \code{Byte}, \code{Short}, \code{Char}, \code{Int}, \code{Long}, \code{Float}, \code{Double}: Undersök hur många bitar som behövs för att representera varje typs omfång? \\*
\textit{Tips:} Några användbara uttryck: \\*
 \code{Integer.toBinaryString(Int.MaxValue + 1).size} \\*
 \code{Integer.toBinaryString((math.pow(2,16) - 1).toInt).size} \\*
 \code{1 + math.log(Long.MaxValue)/math.log(2)}
Se även språkspecifikationen för Scala, kapitlet om heltalsliteraler: \\
\url{http://www.scala-lang.org/files/archive/spec/2.11/01-lexical-syntax.html#integer-literals}

\Subtask Undersök källkoden för paketobjektet \code{scala.math} här: \\
\url{https://github.com/scala/scala/blob/v2.11.7/src/library/scala/math/package.scala} \\
Hur många olika överlagrade varianter av funktionen \code{abs} finns det och för vilka parametertyper är den definierad?

\Task Läs mer om stränginterpolatorer här:\\ \href{http://docs.scala-lang.org/overviews/core/string-interpolation.html}{docs.scala-lang.org/overviews/core/string-interpolation.html} \\ Hur kan du använda \code{f}-interpolatorn för att göra följande utskrift i REPL? Byt ut \code{???} mot lämpliga tecken.
\begin{REPLnonum}
scala> val g: Double = 1 / 3.0
scala> val s: String = f"Gurkan är ??? meter lång"
scala> println(s)
Gurkan är 0.333 meter lång
\end{REPLnonum}

\fi %%% TODO fix solutions
