%!TEX encoding = UTF-8 Unicode
%!TEX root = ../compendium.tex

\Exercise{\ExeWeekTWO}

\begin{Goals}
\item Kunna skapa samlingarna Range, Array och Vector med heltals- och strängvärden.
\item Kunna indexera i en indexerbar samling, t.ex. Array och Vector.
\item Kunna anropa operationerna size, mkString, sum, min, max på samlingar som innehåller heltal.
\item Känna till grundläggande skillnader och likheter mellan samlingarna Range, Array och Vector.
\item Förstå skillnaden mellan en for-sats och ett for-uttryck.
\item Kunna skapa samlingar med heltalsvärden som resultat av enkla for-uttryck.
\item Förstå skillnaden mellan en algoritm i pseudo-kod och dess implementation.
\item Kunna implementera algoritmerna SUM, MIN/MAX på en indexerbar samling med en \code{while}-sats.
\item Kunna köra igång enkel Scala-kod i REPL, som skript och som applikation.
\item Kunna implementera och köra igång ett Java-program. 
\item Känna till några grundläggande syntaxskillnader mellan Scala och Java, speciellt variabeldeklarationer och indexering i Array. 
\item Förstå vad ett block är.
\item Förstå vad en lokal variabel är.
\item Förstå hur nästlade block påverkar namnsynlighet och namnöverskuggning.
\item Förstå kopplingen mellan paketstruktur och klassfilstruktur.
\item Kunna skapa en jar-fil.
\item Kunna skapa dokumentation med scaladoc.
\end{Goals}

\begin{Preparations}
\item Studera teorin i kapitel~\ref{chapter:W02}.
\item Bekanta dig med grundläggande terminalkommandon; se appendix~\ref{appendix:terminal}. 
\item Bekanta dig med den editor du vill använda; se appendix~\ref{appendix:edit}.
\end{Preparations}

\BasicTasks %%%%%%%%%%%%%%%%

\Task  \emph{Datastrukturen \code+Range+.} Evaluera nedan uttryck i Scala REPL. Vad har respektive uttryck för värde och typ?

\Subtask \code{Range(1, 10)}

\Subtask \code{Range(1, 10).inclusive}

\Subtask \code{Range(0, 50, 5)}

\Subtask \code{Range(0, 50, 5).size}

\Subtask \code{Range(0, 50, 5).inclusive}

\Subtask \code{Range(0, 50, 5).inclusive.size}

\Subtask \code{0.until(10)}

\Subtask \code{0 until (10)}

\Subtask \code{0 until 10}

\Subtask \code{0.to(10)}

\Subtask \code{0 to 10}

\Subtask \code{0.until(50).by(5)}

\Subtask \code{0 to 50 by 5}

\Subtask \code{(0 to 50 by 5).size}

\Subtask \code{(1 to 1000).sum}


\Task \label{task:array} \emph{Datastrukturen \code+Array+.} Kör nedan kodrader i Scala REPL. Beskriv vad som händer.

\Subtask \code{val xs = Array("hej","på","dej", "!")}

\Subtask \code{xs(0)}

\Subtask \code{xs(3)}

\Subtask \code{xs(4)}

\Subtask \code{xs(1) + " " + xs(2)}

\Subtask \code{xs.mkString}

\Subtask \code{xs.mkString(" ")}

\Subtask \code{xs.mkString("(", ",", ")")}

\Subtask \code{xs.mkString("Array(", ", ", ")")}

\Subtask \code{xs(0) = 42}

\Subtask \code{xs(0) = "42"; println(x(0))}

\Subtask \code{val ys = Array(42, 7, 3, 8)}

\Subtask \code{ys.sum}

\Subtask \code{ys.min}

\Subtask \code{ys.max}

\Subtask \code{val zs = Array.fill(10)(42)}

\Subtask \code{zs.sum}

\Task \emph{Datastrukturen \code+Vector+.} Kör nedan kodrader i Scala REPL. Beskriv vad som händer.

\Subtask \code{val words = Vector("hej","på","dej", "!")}

\Subtask \code{words(0)}

\Subtask \code{words(3)}

\Subtask \code{words.mkString}

\Subtask \code{words.mkString(" ")}

\Subtask \code{words.mkString("(", ",", ")")}

\Subtask \code{words.mkString("Ord(", ", ", ")")}

\Subtask \code{words(0) = "42"}

\Subtask \code{val numbers = Vector(42, 7, 3, 8)}

\Subtask \code{numbers.sum}

\Subtask \code{numbers.min}

\Subtask \code{numbers.max}

\Subtask \code{val moreNumbers = Vector.fill(10000)(42)}

\Subtask \code{moreNumbers.sum}

\Subtask\Pen Jämför med uppgift \ref{task:array}. Vad kan man göra med en \code{Array} som man inte kan göra med en \code{Vector}?

\Task \emph{\code+for+-uttryck}. Evaluera nedan uttryck i Scala REPL. Vad har respektive uttryck för värde och typ?

\Subtask \code{for (i <- Range(1,10)) yield i}

\Subtask \code{for (i <- 1 until 10) yield i}

\Subtask \code{for (i <- 1 until 10) yield i + 1}

\Subtask \code{for (i <- Range(1,10).inclusive) yield i}

\Subtask \code{for (i <- 1 to 10) yield i}

\Subtask \code{for (i <- 1 to 10) yield i + 1}

\Subtask \code{(for (i <- 1 to 10) yield i + 1).sum}

\Subtask \code{for (x <- 0.0 to 2 * math.Pi by math.Pi/4) yield math.sin(x)}


\Task \emph{Metoden \code+map+ på en samling.} Evaluera nedan uttryck i Scala REPL. Vad har respektive uttryck för värde och typ?

\Subtask \code{Range(0,10).map(i => i + 1)}

\Subtask \code{(0 until 10).map(i => i + 1)}

\Subtask \code{(1 to 10).map(i => i * 2)}

\Subtask \code{(1 to 10).map(_ * 2)}

\Subtask \code{Vector.fill(10000)(42).map(_ + 43)}

\Task \emph{Metoden \code+foreach+ på en samling.} Kör nedan satser i Scala REPL. Vad händer?

\Subtask \code{Range(0,10).foreach(i => println(i))}

\Subtask \code{(0 until 10).foreach(i => println(i))}

\Subtask \code|(1 to 10).foreach{i => print("hej"); println(i * 2)}|

\Subtask \code{(1 to 10).foreach(println)}

\Subtask \code{Vector.fill(10000)(math.random).foreach(r => if (r > 0.99) print("pang!"))}


\Task \emph{Algoritm: SWAP.}

\Subtask Skriv med \emph{pseudo-kod} algoritmen SWAP. Beskriv på vanlig svenska, steg för steg, hur en variabel $temp$ används för mellanlagring vid värdebytet: 

\emph{Indata:} två heltalsvariabler $x$ och $y$ 

\emph{???}

\emph{Utdata:} variablerna $x$ och $y$ vars värden har bytt plats.

\Subtask Implementerar algoritmen SWAP. Ersätt \code{???} nedan med satser separerade av semikolon:

\begin{REPL}
scala> var (x, y) = (42, 43)
scala> ???
scala> println("x är " + x + ", y är " + y)
x är 43, y är 42
\end{REPL}



\Task \emph{Skript.} Skapa med hjälp av en editor en fil med namn \texttt{hello-script.scala} som innehåller denna enda rad:
\begin{Code}
println("hej skript")
\end{Code}
Spara filen och kör kommandot \code{scala hello-script.scala} i terminalen:
\begin{REPLnonum}
> scala hello-script.scala
\end{REPLnonum}

\Subtask Vad händer?

\Subtask Ändra i filen så att högerparentesen saknas. Spara och kör skriptfilen igen. Vad händer?

\Subtask Lägg till en sats sist i skriptet som skriver ut summan av de ett tusen stycken heltalen från och med 2 till och med 1001, så som visas nedan.
\begin{REPL}
> scala hello-script.scala
hej skript
501500
\end{REPL}

\Subtask Ändra i hello-script.scala genom att införa \code{val n = args(0).toInt} och använd \code{n} som övre gräns för summeringen av de n första heltalen.
\begin{REPL}
> scala hello-script.scala 5001
hej skript
12507501
\end{REPL}

\Subtask Vad blir det för felmeddelande om du glömmer ge programmet ett argument?


\Task \emph{Applikation med \code+main+-metod.} Skapa med hjälp av en editor en fil med namn \texttt{hello-app.scala}.
\begin{REPLnonum}
> gedit hello-app.scala
\end{REPLnonum}
Skriv dessa rader i filen:


\scalainputlisting{examples/hello-app.scala}

\Subtask Kompilera med \code{scalac hello-app.scala} och kör koden med \code{scala Hello}.
\begin{REPLnonum}
> scalac hello-app.scala
> ls
> scala Hello
\end{REPLnonum}
Vad heter filerna som kompilatorn skapar?

\Subtask Ändra i din kod så att kompilatorn ger följande felmeddelande: \\
\texttt{Missing closing brace}

\Subtask\Pen Varför behövs \code{main}-metoden?

\Subtask\Pen Vilket alternativ går snabbast att köra igång, ett skript eller en kompilerad applikation? Varför? Vilket alternativ kör snabbast när väl exekveringen är igång?


\Task \label{task:java} \emph{Java-applikation.} Skapa med hjälp av en editor en fil med namn \texttt{Hi.java}.
\begin{REPLnonum}
> gedit Hi.java
\end{REPLnonum}
Skriv dessa rader i filen:

\javainputlisting{examples/Hi.java}

\noindent Kompilera med \code{javac Hi.java} och kör koden med \code{java Hi}.
\begin{REPLnonum}
> javac Hi.java
> ls
> java Hi
\end{REPLnonum}

\Subtask\Pen Vad heter filen som kompilatorn skapat?

\Subtask\Pen Jämför signaturen för Java-programmets main-metod med signaturen för Scala-programmets main-metod. De betyder samma sak men syntaxen är olika. Beskriv skillnader och likheter i syntaxen.

\Subtask\Pen Vad blir det för felmeddelande om källkodsfilen och klassnamnet inte överensstämmer i ett Java-program?


\Task \emph{Algoritm: SUMBUG}. Nedan återfinns pseudo-koden för SUMBUG. 

\begin{algorithm}[H]
 \SetKwInOut{Input}{Indata}\SetKwInOut{Output}{Resultat}
 
 \Input{heltalet $n$}
 \Output{utskrift av summan av de första $n$ heltalen }
 $sum \leftarrow 0$ \\
 $i \leftarrow 1$  \\
 \While{$i \leq n$}{
  $sum \leftarrow sum + 1$
 }
 skriv ut $sum$
\end{algorithm}

\Subtask\Pen Kör algoritmen steg för steg med penna och papper, där du skriver upp hur värdena fär respektive variabel ändras. Det finns en bugg i algoritmen. Vilken? Rätta buggen.

\Subtask Skapa med hjälp av en editor filen \code{sumn.scala}. Implementera algoritmen SUM enligt den rättade pseudokoden och placera implementationen i en main-metod i ett objekt med namnet \code{sumn}. Du kan skapa indata \code{n} till algoritmen med denna deklaration i början av din main-metod: \\ \code{val n = args(0).toInt} \\ Vad ger applikationen för utskrift om du kör den med argumentet 8888? 

\begin{REPLnonum}
> scalac sumn.scala
> scala sumn 8888
\end{REPLnonum}

\Subtask Kontrollera att din implementation räknar rätt genom att jämföra svaret med detta uttrycks värde, evaluerat i Scala REPL:
\begin{REPLnonum}
scala> (1 to 8888).sum
\end{REPLnonum}

\Subtask Implementera algoritmen SUM enligt pseudokoden ovan, men nu i Java. Skapa filen \code{SumN.java} och använd koden från uppgift \ref{task:java} som mall för att deklarera den publika klassen \code{SumN} med en main-metod. Några tips om Java-syntax och standarfunktioner i Java: 

\begin{itemize}[noitemsep, nolistsep]
\item Alla satser i Java måste avslutas med semikolon.
\item Heltalsvariabler deklareras med nyckelordet \lstinline[language=Java]{int} (litet i). 
\item Typnamnet ska stå \emph{före} namnet på variabeln. Exempel: \\ \lstinline[language=Java]{int sum = 0;}
\item Indexering i en array görs i Java med hakparenteser: \code{args[0]}
\item I stället för Scala-uttrycket \code{args(0).toInt}, använd Java-uttrycket: \\ \code{Integer.parseInt(args[0])}
\item \code{while}-satser i Scala och Java har samma syntax.
\item Utskrift i Java görs med \code{System.out.println}
\end{itemize}


\Task \emph{Algoritm: MAXBUG}. Nedan återfinns pseudo-koden för MAXBUG. 

\begin{algorithm}[H]
 \SetKwInOut{Input}{Indata}\SetKwInOut{Output}{Resultat}
 
 \Input{Array $args$ med strängar som alla innehåller heltal}
 \Output{utskrift av största heltalet }
 $max \leftarrow$ det minsta heltalet som kan uppkomma  \\
 $n \leftarrow $ antalet heltal \\
 $i \leftarrow 0$ \\
 \While{$i < n$}{
   $x \leftarrow args(i).toInt$ \\
   \If{( x > $max$)}{$max \leftarrow x$} 
  % $i \leftarrow i + 1$
 }
 skriv ut $max$
\end{algorithm}

\Subtask\Pen Kör med penna och papper. Det finns en bugg i algoritmen ovan. Vilken? Rätta buggen.

\Subtask Implementera algoritmen MAX (utan bugg) som en Scala-applikation. Tips:
\begin{itemize}[noitemsep, nolistsep]
\item Det minsta heltalet som någonsin kan uppkomma: \code{Int.MinValue}
\item Antalet element i $args$ ges av: \code{args.size}
\end{itemize}

\begin{REPL}
> gedit maxn.scala
> scalac maxn.scala
> scala maxn 7 42 1 -5 9
42
\end{REPL}

\Subtask\Pen \label{subtask:arg0} Skriv om algoritmen så att variablen $max$ initialiseras med det första talet i sekvensen. 

\Subtask Implementera den nya algoritmvarianten från uppgift \ref{subtask:arg0} och prova programmet. Vad händer om $args$ är tom?

\Task \emph{Block, namnsynlighet, namnöverskuggning}. Kör nedan kod i Scala REPL eller i Kojo. Vad händer nedan? Varför?

\Subtask \code|val a = {1 + 1; 2 + 2; 3 + 3; 4 + 4}; println(a)|

\Subtask \code|val b = {1; 2; 3; {val b = 4; b + b; b + 1}}; println(b)|

\Subtask \code|{val a = 42; println(a)}|

\Subtask \code|{val a = 42}; println(a)|

\Subtask \code|{val a = 42; {val a = 43; println(a)}; println(a)}|

\Subtask \code|{var a = 42; {a = a + 1}; var a = 43}|

\Subtask \code|{var a = 42; {a = a + b; var b = 43}; println(a)}|

\Subtask \code|{var a = 42; {var b = 43; a = a + b}; println(a)}|

\Subtask \code|{var a = 42; {a = a + b; def b = 43}; println(a)}|

\Subtask \code|{object a{var b=42;object a{var a=43}};println(a.b+a.a.a)}|

\Subtask 

\begin{Code}
{
  object a {
    var b = 42
    object a {
      var a = 43
    }
  }
  println(a.b + a.a.a)
}
\end{Code}

\Subtask Vad är fördelen med att namn deklararerade inne i ett block är lokala i stället för globala?


\Task \label{task:package} \emph{Paket, \code{import} och klassfilstrukturer.} Med Java-8-plattformen kommer 4240 färdiga klasser, som är organiserade i 217 olika paket.\footnote{Se Stackoverflow: \href{http://stackoverflow.com/questions/3112882/how-many-classes-are-there-in-java-standard-edition}{how-many-classes-are-there-in-java-standard-edition}}

\Subtask Vilka paket finns i paketet javax som börjar på s?

\begin{REPLnonum}
scala> javax.s   //tryck på TAB-tangenten
\end{REPLnonum} 

\Subtask Kör raderna nedan i REPL. Beskriv vad som händer för varje rad.
\begin{REPL}[numbers=left, numberstyle=\color{black}\ttfamily\scriptsize\selectfont]
scala> import javax.swing.JOptionPane
scala> def msg(s: String) = JOptionPane.showMessageDialog(null, s)
scala> msg("Hej på dej!")
scala> def input(msg: String) = JOptionPane.showInputDialog(null, msg)
scala> input("Vad heter du?")
scala> import JOptionPane.{showOptionDialog => optDlg}
scala> def inputOption(msg: String, opt: Array[Object]) = 
         optDlg(null, msg, "Option", 0, 0, null, opt, opt(0))
scala> inputOption("Vad väljer du?", Array("Sten", "Sax", "Påse"))
\end{REPL} 

\Subtask\Pen Vad hade du behövt ändra på efterföljande rader om import-satsen på rad 1 ovan ej hade gjorts?

\Subtask Skapa med en editor filen paket.scala och kompilera. Rita en bild av hur katalogstrukturen ser ut.

\begin{Code}
package gurka.tomat.banan

package p1 {
  package p11 {
    object hello {
      def hello = println("Hej paket p1.p11!")
    }
  }
  package p12 {
    object hello {
      def hello = println("Hej paket p1.p12!")
    }
  }
}

package p2 {
  package p21 {
    object hello {
      def hello = println("Hej paket p2.p21!")
    }
  }
}

object Main {
  def main(args: Array[String]): Unit = {
    import p1._
    p11.hello.hello
    p12.hello.hello
    import p2.{p21 => apelsin}
    apelsin.hello.hello
  }
}
\end{Code}

\begin{REPL}
> gedit paket.scala
> scalac paket.scala
> scala gurka.tomat.banan.Main
> ls -R
\end{REPL}

\Task \emph{Skapa \code{jar}-filer och använda classpath}

\Subtask Skriv kommandot \code{jar} i terminalen och undersök vad som finns för optioner. Se speciellt ''Example 1.'' i hjälputskriften. Vilket kommando ska du använda för att packa ihop flera filer i en enda jar-fil?

\Subtask Som en fortsättning på uppgift \ref{task:package}, packa ihop biblioteket \code{gurka} i en jar-fil med nedan kommando, samt kör igång REPL med jar-filen på classpath.

\begin{REPL}
> jar cvf mittpaket.jar gurka
> scala -cp mittpaket.jar
scala> gurka.tomat.banan.Main.main(Array())
\end{REPL}

 
\Task \emph{Skapa dokumentation med \code{scaladoc}-kommandot}

\Subtask Som en fortsättning på uppgift \ref{task:package}, kör nedan kommando i terminalen:

\begin{REPL}
> scaladoc paket.scala
> ls
> firefox index.html   # eller öppna index.html i valfri webbläsare
\end{REPL}

Vad händer?

\Subtask Lägg till några fler metoder i något av objekten i filen \code{paket.scala} och lägg även till några dokumentationskommentarer. Kompilera om och kör. Generera om dokumentationen. 

\begin{verbatim}
//... ändra i filen paket.scala

/** min paketdokumentationskommentar p2 */
package p2 {
  /** min paketdokumentationskommentar p21 */
  package p21 {
    /** ett hälsningsobjekt */
    object hello {
      /** en hälsningsmetod i p2.p21 */
      def hello = println("Hej paket p2.p21!")
      
      /** en metod som skriver ut tiden */
      def date = println(new java.util.Date)
    }
  }
}

\end{verbatim}

\begin{REPL}
> gedit paket.scala
> scalac paket.scala
> jar cvf mittpaket.jar gurka
> scala -cp mittpaket.jar
scala> gurka.tomat.banan.p2.p21.hello.date
scala> :q
> scaladoc paket.scala
> firefox index.html
\end{REPL}

\ExtraTasks %%%%%%%%%%%%%%%%%%%



\AdvancedTasks %%%%%%%%%%%%%%%%%


\Task ArrayBuffer vs Vector vs Array och metoden append

\Task Läs om krullparenetser och vanliga parenteser på stack overflow: \\ \href{http://stackoverflow.com/questions/4386127/what-is-the-formal-difference-in-scala-between-braces-and-parentheses-and-when}{what-is-the-formal-difference-in-scala-between-braces-and-parentheses-and-when}

\Task Bygg vidare på koden nedan och gör ett Sten-Sax-Påse-spel\footnote{\href{https://sv.wikipedia.org/wiki/Sten,\_sax,\_p\%C3\%A5se}{sv.wikipedia.org/wiki/Sten,\_sax,\_p\%C3\%A5se}} som även meddelar vem som vinner. Koden fungerar att köra som den är, men funktionen \code{winnerMsg} är ej klar. \emph{Tips:} Du kan använda modulo-räkning med \%-operatorn för att avgöra vem som vinner.

\begin{Code}[basicstyle=\ttfamily\footnotesize\selectfont]]
object Rock {
  import javax.swing.JOptionPane
  import JOptionPane.{showOptionDialog => optDlg}
  
  def inputOption(msg: String, opt: Vector[String]) = 
    optDlg(null, msg, "Option", 0, 0, null, opt.toArray[Object], opt(0))
    
  def msg(s: String) = JOptionPane.showMessageDialog(null, s)  
  
  val opt =  Vector("Sten", "Sax", "Påse")
   
  def userChoice = inputOption("Vad väljer du?", opt)
  
  def computerChoice = (math.random * 3).toInt     
  
  def winnerMsg(user: Int, computer: Int) = "??? vann!"
  
  def main(args: Array[String]): Unit = {
    var keepPlaying = true
    while (keepPlaying) {
      val u = userChoice
      val c = computerChoice
      msg("Du valde " + opt(u) + "\n" + 
          "Datorn valde " + opt(c) + "\n" + 
          winnerMsg(u, c))
      if (u != c) keepPlaying = false 
    }
  }
}
\end{Code}