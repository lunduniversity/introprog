%!TEX encoding = UTF-8 Unicode
%!TEX root = ../solutions.tex

\ExerciseSolution{\ExeWeekTWO}

%Uppgift 1
\Task 

\Subtask värde: \code{Range(1,2,3,4,5,6,7,8,9)}

typ: \code{scala.collection.immutable.Range}

\Subtask värde: \code{Range(1,2,3,4,5,6,7,8,9,10)}

typ: \code{scala.collection.immutable.Range}

\Subtask värde: \code{Range(0,5,10,15,20,25,30,35,40,45)}

 typ: \code{scala.collection.immutable.Range}

\Subtask värde: \code{10}, typ: \code{Int}

\Subtask värde: \code{Range(0,5,10,15,20,25,30,35,40,45,50)}

typ: \code{scala.collection.immutable.Range}

\Subtask värde: \code{11}, typ: \code{Int}

\Subtask värde: \code{Range(0,1,2,3,4,5,6,7,8,9)}

typ: \code{scala.collection.immutable.Range}

\Subtask värde: \code{Range(0,1,2,3,4,5,6,7,8,9)}

typ: \code{scala.collection.immutable.Range}

\Subtask värde: \code{Range(0,1,2,3,4,5,6,7,8,9)}

typ: \code{scala.collection.immutable.Range}

\Subtask värde: \code{Range(0,1,2,3,4,5,6,7,8,9,10)}

typ: \code{scala.collection.immutable.Range.Inclusive}

\Subtask värde: \code{Range(0,1,2,3,4,5,6,7,8,9,10)}

typ: \code{scala.collection.immutable.Range.Inclusive}

\Subtask värde: \code{Range(0,5,10,15,20,25,30,35,40,45)}

typ: \code{scala.collection.immutable.Range}

\Subtask värde: \code{Range(0,5,10,15,20,25,30,35,40,45,50)}

typ: \code{scala.collection.immutable.Range}

\Subtask värde: \code{11}, typ: \code{Int}

\Subtask värde: \code{500500}, typ: \code{Int}


%Uppgift 2
\Task 

\Subtask Ett objekt av typen \code{Array[String]} skapas med värdet 

\code{Array(hej, på, dej, !)} och med namnet \code{xs}.

\Subtask Returnerar en sträng med värdet \code{hej}.

\Subtask Returnerar en sträng med värdet \code{!}.

\Subtask Ett exception genereras. Skriver ut:

\code{java.lang.ArrayIndexOutOfBoundsException: 4}

\Subtask Returnerar en sträng med värdet \code{på dej}.

\Subtask Returnerar en sträng med värdet \code{hejpådej!}.

\Subtask Returnerar en sträng med värdet \code{hej på dej !}.

\Subtask Returnerar en sträng med värdet \code{(hej,på,dej,!)}.

\Subtask Returnerar en sträng med värdet \code{Array(hej,på,dej,!)}.

\Subtask Ett fel uppstår av typen \code{type mismatch}. Konsollen talar om för oss vad den fick, dvs värdet \code{42} av typen \code{Int}. Den talar även om för oss vad den ville ha, dvs något värde av typen \code{String}. Till sist skriver den ut vår kodrad och pekar ut felet.

\Subtask Det första elementet i \code{xs} ändras till värdet \code{42}. Därefter skrivs det första värdet i \code{xs} ut.

\Subtask Ett objekt av typen \code{Array[Int]} skapas med värdet \code{Array(42, 7, 3, 8)} och med namnet \code{ys}.

\Subtask Returnerar summan av elementen i \code{ys}. Resultatet är \code{60}.

\Subtask Returnerar det minsta värdet i \code{ys}. Resultatet är \code{3}.

\Subtask Returnerar det största värdet i \code{ys}. Resultatet är \code{42}.

\Subtask Ett nytt värde av typen \code{Array[Int]} skapas med \code{10} stycken element, alla med värdet \code{42}.

\Subtask Returnerar summan av elementen i \code{zs}. Resultatet blir 420 (42 multiplicerat med 10).

\Subtask \code{r} tar upp 12 bytes. \code{a} tar upp ca 4 miljarder bytes.

%Uppgift 3
\Task 

\Subtask Ett objekt av typen \code{scala.collection.immutable.Vector[String]} initieras med värdet \code{Vector(hej, på dej, !)}.

\Subtask Returnerar det nollte elementet i \code{words}, dvs strängen \code{hej}.

\Subtask Returnerar det tredje elementet i \code{words}, dvs strängen \code{!}.

\Subtask Omvandlar vektorn till en Sträng.

\Subtask Samma som ovan, fast den här gången används mellanrum för att seperera elementen.

\Subtask Samma som ovan, fast den här gången sepereras elementen av kommatecken istället för mellanrum och dessutom börjar och slutar den resulterande strängen med parenteser.

\Subtask Samma som ovan, fast med ordet \code{Ord} tillagt i början av den resulterande strängen.

\Subtask Ett fel uppstår. Typen \code{Vector} är immutable. Dess element kan alltså inte bytas ut.

\Subtask En ny \code{Vector[Int]} skapas med värdet \code{Vector(42, 7, 3, 8)}. 

\Subtask Returnerar summan av vektorn \code{numbers}.

\Subtask Returnerar vektorns minsta element.

\Subtask Returnerar vektorns största element. 

\Subtask En ny vektor skapas innehållandes tiotusen 42or.

\Subtask Returnerar summan av vektorns element.

\Subtask Byta ut element.

%Uppgift 4
\Task 

\Subtask typ: \code{scala.collection.immutable.IndexedSeq[Int]}

värde: \code{Vector(1, 2, 3, 4, 5, 6, 7, 8, 9)}

\Subtask typ: \code{scala.collection.immutable.IndexedSeq[Int]}

värde: \code{Vector(1, 2, 3, 4, 5, 6, 7, 8, 9)}

\Subtask typ: \code{scala.collection.immutable.IndexedSeq[Int]}

värde: \code{Vector(2, 3, 4, 5, 6, 7, 8, 9, 10)}

\Subtask typ: \code{scala.collection.immutable.IndexedSeq[Int]}

värde: \code{Vector(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)}

\Subtask typ: \code{scala.collection.immutable.IndexedSeq[Int]}

värde: \code{Vector(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)}

\Subtask typ: \code{scala.collection.immutable.IndexedSeq[Int]}

värde: \code{Vector(2, 3, 4, 5, 6, 7, 8, 9, 10, 11)}

\Subtask typ: \code{Int}, värde: \code{Vector(65)}

\Subtask typ: \code{scala.collection.immutable.IndexedSeq[Int]}

värde: \code{Vector(0.0, 0.707, 1.0, 0.707, 0.0, -0.707, -1.0, -0.707)}

%Uppgift 5
\Task 

\Subtask typ: \code{scala.collection.immutable.IndexedSeq[Int]}

värde: \code{Vector(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)}

\Subtask typ: \code{scala.collection.immutable.IndexedSeq[Int]}

värde: \code{Vector(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)}

\Subtask typ: \code{scala.collection.immutable.IndexedSeq[Int]}

värde: \code{Vector(2, 4, 6, 8, 10, 12, 14, 16, 18, 20)}

\Subtask typ: \code{scala.collection.immutable.IndexedSeq[Int]}

värde: \code{Vector(2, 4, 6, 8, 10, 12, 14, 16, 18, 20)}

\Subtask typ: \code{scala.collection.immutable.Vector[Int]}

värde: En vector av tiotusen 85or (85 = 42 + 43).

%Uppgift 6
\Task 

\Subtask En \code{Range} skapas och dess element skrivs ut ett och ett.

\Subtask Samma sak händer.

\Subtask De tio första första jämna talen (noll ej inräknat) skrivs ut med ett "hej" framför.

\Subtask Talen 1 till 10 skrivs ut.

\Subtask Tiotusen slumptal mellan 0 och 1 genereras. Varje gång ett tal är större än 0.99 kommer det ett pling.

%Uppgift 7
\Task 

\Subtask Pseudokoden kan se ut såhär:

Skapa heltalsvariabel temp. 
Flytta värdet från x till temp. 
Flytta värdet från y till x. 
Flytta värdet från temp till y.

\Subtask
\begin{REPLnonum}
scala> var (x, y) = (42, 43)
x: Int = 42
y: Int = 43
scala> var temp = x; x = y; y = temp;
temp: Int = 42
x: Int = 43
y: Int = 42
scala> println("x är " + x + ", y är " + y)
x är 43, y är 42
\end{REPLnonum}

%Uppgift 8
\Task 

\Subtask Skriver ut "hej skript".

\Subtask Ett felmeddelande skrivs ut.

\Subtask Lägg till raden:
\code{println((2 to 1001).sum)} 
eller motsvarande.

\Subtask Filen ska se ut ungefär såhär: \\
\begin{Code} 
val n = args(0).toInt 
println("hej skript") 
println((1 to n).sum)
\end{Code}

\Subtask \code{java.lang.ArrayIndexOutOfBoundsException: 0}

%Uppgift 9
\Task 

\Subtask Hello.class och Hello\$.class

\Subtask Ta bort en av hakparenteserna i slutet.

\Subtask I ett skript behöver man inte skriva någon main-metod. Kompilatorn lägger till en automatiskt precis när koden ska köras. I en applikation behöver man däremot det. För att göra en applikation definierar vi ett objekt som vi i det här fallet kallar för \code{Hello}. Från början gör inte objekt någonting. De bara finns. För att objekt ska kunna göra något behövs det metoder. I vanliga fall utförs inte metoder förrän en annan metod "ropar" på metoden. main-metoden ropas dock automatiskt när en applikation startas. Annars hade ju ingenting hänt, eftersom alla metoderna väntar på att någon annan metod ska börja. \\
\Subtask Första gången man ska köra en applikation måste den först kompileras innan den exekveras. Skript kompileras automatiskt samtidigt som de exekveras, vilket totalt sett görs på kortare tid. Därför tar det längre tid att starta en applikation första gången än att starta ett skript första gånge. När en applikation väl har kompileras och kan exekveras, går det dock mycket fortare. Fördelen med applikationer är att de kan exekveras flera gånger utan att kompileras om.

%Uppgift 10
\Task 

\Subtask Hi.class

\Subtask I javas syntax börjar man med orden \code{public static}. I scala uteblir dessa. I scala är alla metoder automatiskt publika om inget annat används. Därför behövs aldrig ordet \code{public} i scala. I scala finns det tekniskt sett inga statiska metoder. Men i praktiken fungerar vanliga metoder i ett scala-objekt på ungefär samma sätt som statiska metoder i en java-klass. I scala används ordet \code{def} varje gång en funktion ska definieras. I java slipper man det. I java skriver man returtypen (\code{void}) innan parametrarna. I scala kommer istället metodens returtyp (\code{Unit}) i slutet. Javas \code{void} motsvarar scalas \code{Unit}. I scalas syntax kommer parameterns namn (\code{args}) före parameterns typ (\code{Array[String]}), separerat med ett kolon. I java kommer typen (\code{String[]}) först och sen kommer namnet (\code{args}). \code{String[]} i java betyder ungefär samma sak som \code{Array[String]} i scala.

\Subtask -

%Uppgift 11
\Task 

\Subtask Bugg: Eftersom \code{i} inte ökar, fastnar programmet i en oändlig loop. Fix: Lägg till en sats i slutet av while-blocket som ökar värdet på i med 1.
Bugg: Eftersom man bara ökar summan med 1 varje gång, kommer resultatet att bli summan av n stycken 1or, inte de n första heltalen. Fix: Ändra så att summan ökar med \code{i} varje gång, istället för 1.
För -1, blir resultatet 0. Förklaring: i börjar på 1 och är alltså aldrig mindre än n som ju är -1. while-blocket genomförs alltså noll gånger, och efter att \code{sum} får sitt ursprungsvärde förändras den aldrig.
\Subtask 39502716
\Subtask -
\Subtask Såhär kan implementationen se ut:
\begin{Code}
public class SumN {
  public static void main(String[] args) {
    int n = Integer.parseInt(args[0]);
    int sum = 0;
    int i = 1;
    while(i <= n){
      sum = sum + i;
      i = i + 1;
      }
    }
    System.out.println(sum);
}
\end{Code}

%Uppgift 12
\Task 

\Subtask Bugg: i ökar aldrig. Programmet fastnar i en oändlig loop. Fix: Lägg till en sats som ökar i med 1, i slutet av while-blocket.

\Subtask Så här kan implementationen se ut:
\begin{Code}
object Max {
  def main(args: Array[String]): Unit = {
    var max = Int.MinValue
    val n = args.size
    var i = 0
    while(i < n) {
      val x = args(i).toInt
      if(x > max) {
        max = x
      }
      i = i + 1
    }
    println(max)
  }
}
\end{Code}
\Subtask Raden där max initieras ändras till \code{var max = args(0).toInt} 

\Subtask \code{java.lang.ArrayIndexOutOfBoundsException: 0}

%Uppgift 13
\Task

\Subtask Skriver ut talet 8. \code{a} får värdet \code{4 + 4} eftersom detta är den sista satsen i blocket. Man får också tre stycken varningar. Detta beror på att det förekommer tre satser i blocket som inte gör någon skillnad.

\Subtask Skriver ut talet 5. De tre första satserna i det yttre blocket ignoreras. \code{b} får värdet som returneras av det yttre blocket. Det yttre blocket returnerar värdet som returneras i den sista satsen i blocket, som i sin tur är ett block. I det inre blocket skapas en ny \code{val} som också får namnet \code{b}. Notera att detta alltså inte är samma värde, även om det har samma namn. Den andra satsen räknar summan av \code{b} med sig själv. Eftersom vi nu befinner oss i det block där det andra \code{b}et precis har definieras så är det detta \code{b} som används och summan blir alltså åtta. Detta är dock helt irrelevant eftersom resultatet inte sparas någonstans. I den sista satsen blir resultatet 5 (eftersom \code{b} är fyra och vi adderar ett). Detta resultatet returneras från det innre blocket och vidare ur det yttre blocket.

\Subtask Skriver ut talet 42. Blockets satser exekveras i ordning. 

\Subtask Skriver inte ut 42. I blocket skapas ett \code{val} med namnet \code{a} och värdet \code{42}. Detta värde finns inte utanför blocket och kommer därför inte att skrivas ut. Om du däremot definierat \code{a} som något annat tidigare så kommer istället det värdet att skrivas ut.

\Subtask Skriver först ut \code{43} och sedan \code{42}. Förklaring:

\code{a} initieras med värdet \code{42}. Ett nytt värde som också har namnet \code{a} initieras med värdet \code{43}. Eftersom detta sker innanför ett nytt block, befinner vi oss i ett annat "namespace" och det gör alltså inget att vi använder samma namn. \code{a} skrivs ut. Eftersom vi befinner oss i det inre blocket är det \code{43} som skrivs ut, inte \code{42}. Scala kollar först efter värden som heter \code{a} i det inre "namespacet". Det är först i andra hand som den skulle upptäcka att det finns ett \code{a} i det yttre blocket. Till sist körs den sista satsen i det yttre blocket. Då skrivs \code{a} ut. Eftersom vi nu befinner oss i det yttre blocket, vet inte ens scala om att det andra \code{a}:et existerar. Resultatet av den här utskriften blir alltså \code{42}.

\Subtask Ett fel uppstår. Variabeln \code{a} initieras två gånger i samma namespace. Förklaring till felet:

I det yttre blockets första sats initieras variablen \code{a} med värdet \code{42}. I det yttre blockets tredje sats försöker vi definiera en ny variabel med samma namn. I och med att vi befinner oss i samma namespace, krockar namnen.

Förklaring till vad som händer i sats två:

I det inre blocket har vi inte definierat någon variabel \code{a}. Till en början hittar alltså inte scala något sådant. Då letar scala vidare i det namespace som finns utanför det inre blocket och hittar variabeln som vi definierade i det yttre blockets första sats. Denna variabel får sitt värde förändrat.

\Subtask Fel. Framåtreferens. Förklaring:

Det är inte tillåtet att referera till variabler som initieras senare i koden.

\Subtask Skriver ut \code{85}. Förklaring:

I och med att vi den här gången initierade variabeln \code{b} och gav den ett värde innan vi använder oss av den, slipper vi problemet ovan.

\Subtask Skriver ut \code{85}. Förklaring:

Det är tillåtet att referera till funktioner som definieras senare i koden.

\Subtask Skriver ut \code{85}. Förklaring:

\code{a.b} refererar till variabeln \code{b} som ingår i objektet \code{a}.
\code{a.a.a} refererar till variabeln \code{a}, som ingår i ett objekt som heter \code{a} som i sin tur befinner sig i ett annat objekt som också heter \code{a}.

\Subtask Skriver ut \code{85}. Förklaring:

Koden är identisk med förra deluppgiften förutom att ny rad används istället för semikolon.

\Subtask I stora projekt med mycket kod, kan det vara svårt att hitta unika namn till alla sina variabler. Då är det en fördel om man kan hålla sina variabler i begränsade namespaces, så att de bara är tillgängliga precis när de behöver användas. 

%Uppgift 14??? NUMMER I KOMMENTAR STÄMMER EJ MED GENERERAT NUMMER
\Task 

\Subtask \code{script   security   smartcardio   sound   sql   swing}

\Subtask Radernas funktion i ordning:

1. Importerar JOptionPane från javax.swing

2. Definierar en metod som tar en sträng och öppnar en dialogruta med strängen.

3. Testar funktionen med argumentet "Hej på dej!". En dialogruta öppnas med texten "Hej på dej!".

4. Definierar en metod som tar emot en sträng som argument och öppnar en input-dialogruta med strängen.

5. Testar funktionen med argumentet "Vad heter du?". En dialogruta öppnas med texten "Vad heter du?". I ett fält kan man fylla i sitt namn. Funktionen returnerar namnet.

6. Importerar showOptionDialog från JOptionPane under namnet optDlg.

7. Definierar en metod som tar emot en sträng och en Array som argument och öppnar en flervalsdialog. Strängen ska innehålla frågan som flervalsdialogen visar upp. Arrayn ska innehålla alternativen som användaren ska välja mellan.

8.Testar funktionen med argumenten \code{"Vad väljer du?"} och \\ \code{Array("Sten, "Sax", "Påse")}. En dialogruta kommer upp och man får möjlighet att välja sten sax eller påse. Funktionen returnerar valet som man gör.

\Subtask På alla ställen där \code{JOptionPane} förekommer, hade man istället fått skriva \code{javax.swing.JOptionPane}.

\Subtask -

%Uppgift 15
\Task 

\Subtask jar cvf [namn på skapad fil] [namn på input-filer]

\Subtask -

%Uppgift 16
\Task 

\Subtask -

\Subtask -
