%!TEX encoding = UTF-8 Unicode
%!TEX root = ../compendium2.tex

\Assignment{tictactoe}

\begin{Goals}
	\item Implementera ett helt program efter specifikation.
	\item Få en inblick i hur rekursion kan användas, utöver svans-rekursion.
	\item Bli introducerad till spelteori och hur man kan uttrycka optimal strategi för spelet tictactoe.
	\item Träna på att använda abstrakta klasser.
	\item Kunna byta mellan representationer av en spelplan.
\end{Goals}

\subsection{Bakgrund}
I detta projektet ska du implementera din egen version av spelet tic-tac-toe (eller som vi på svenska kallar det, tre i rad)! Du kommer börja med att implementera en version där du kan spela mot en kursare och sen gå vidare till att implementera en datorspelare som lägger sin pjäs slumpmässigt och till slut en som inte kan förlora!

\subsection{Regler}
Om du känner dig säker på hur reglerna i tic-tac-toe funkar kan du skippa detta.\footnote{\href{https://en.wikipedia.org/wiki/Tic-tac-toe}{en.wikipedia.org/wiki/Tic-tac-toe}}
\begin{itemize}
	\item Spelplanen består av ett rutnät av storlek 3x3.
	\item Det finns två spelare: \texttt{x} och \texttt{o}.
	\item Spelarna placerar ut en pjäs var i växlande ordning där \texttt{x} börjar.
	\item Om en spelare har fått antingen en rad, diagonal eller kolumn ifylld av sin spelpjäs vinner den spelaren. Om hela spelplanen blir fylld utan att någon vinner slutar spelet oavgjort.
\end{itemize}
\textit{Notera att pjäserna INTE får flyttas när de väl ligger på spelplanen.}

\subsection{Teori}

Representationen är vald till en endimensionell array av typen \code{Int} av storlek 9 där element $[0,2]$\footnote{Med beteckningen $[x,y]$ menas alla heltal från och med $x$ till och med $y$, dvs: $x$, $x+1$, $x+2$, \ldots , $y-1$, $y$. Kortfattat så är $[0,2]$ = \code{\{0,1,2\}}.} representerar den första raden, $[3,5]$ den andra och $[6,8]$ den tredje. Anledningen till detta är att vi vill ha en representation så att spelaren kan svara vilket drag den vill göra med ett heltal.
Varje element i arrayen ska kunna representera en tom plats, en plats allokerad av \texttt{x} och en plats allokerad av \texttt{o}. Detta innebär att en array av typen \code{Boolean} inte räcker till. Istället väljs den (kanske lite minnesöverflödiga) typen \code{Int}. Vi har valt representationen där 0 representerar tom plats, 1 representerar \texttt{x} och -1 representerar \texttt{o}. Denna representation är smidig dels för vår framtida \code{OptimalPlayer} och dels för att avgöra om spelare \texttt{x} eller \texttt{o} har vunnit. Man kan exempelvis summera en rad och kolla om radens summa är 3 (då har \texttt{x} vunnit) eller -3 (då har \texttt{o} vunnit).

\subsection{Design}
Den här uppgiften kommer innehålla lite färre klasser och mindre objekt\-orienterade utmaningar, men istället lite klurigare algoritmiska utmaningar. Vi skall dessutom använda rekursion till vår fördel, vilket för den ovane brukar vara krångligt, därför hamnar huvudfokus här. Programmet har följande klasstruktur:

\code{Game}. I sin mainmetod frågar den användaren hur spelen skall gå till och med vilka spelare.
När detta är specificerat anropas den rekursiva metoden \code{play}.
\code{play} spelar ett spel mellan två spelare tills någon vinner eller det blir oavgjort.
Kodskelettet för \code{Game} ser ut på följande vis:
\begin{ScalaSpec}{Game}
/**
 * Asks the user what kind of players should play against each other.
 * Creates the players that the user chooses via System.in
 * Asks the user if the board should be drawn.
 * If the board should not be drawn, ask the user for n,
 * the amount of games that should be played between the two players.
 * Else n = 1.
 * Call play n times with the two players, an empty board, depth = 0,
 * and drawing true/false dependent on if the board should be printed or not.
 * Save the resuts from play.
 * Present the results after n games have been played.
 */
def main(args: Array[String]): Unit = ???

/**
 * p1 and p2 are the players that should play the game.
 * depth models amount of moves done by both players.
 * drawing is true if draw should be called before each move.
 *(1) If drawing: call draw(game)
 *(2) If game is won by any of the players, or depth == 9,
 * return 1 if p1 wins, -1 if p2 wins and 0 if there is a draw.
 *(3) Else: Asks player 1 for its move if depth%2 == 0, else ask player 2.
 *(4) Update game according to the move p1 or p2 does.
 *(5) Return play(p1,p2,game,depth+1,drawing) (if someone wins with
 * the current move, it will be detected by (2) in this call of play)
 */
def play(p1: Player, p2: Player, game: Array[Int],
         depth: Int, drawing: Boolean): Int = ???

/**
 * Given an Array[Int] game of size 9,
 * print the 3x3 board that the array represents.
 * [0,2] is the 1st, [3,5] is the 2nd and [6,8] is the 3rd row.
 * -1 should be represented by 'o', 0 with '.' and 1 with 'x'.
 * In particular, [0,1,-1,0,0,1,0,1,-1] should print:
 * .xo
 * ..x
 * .xo
 */

def draw(game:Array[Int]): Unit = ???
\end{ScalaSpec}

\code{Player}. Denna abstrakta klass kommer innehålla gemensam logik för players. För att inte göra våra players beroende av \code{Game }har vi valt att lägga en metod \code{gameWon} i \code{Player}. Valet av placering av denna metod kan definitivt diskuteras. Man skulle kunna tänka sig att denna metod borde ligga i ett util-objekt eller liknande, men för tillfället är det bara denna metod som man skulle vilja ha i ett sådant objekt vilket gör det klumpigt. Anledningen till att den istället hamnat hos \code{Player} är att både \code{OptimalPlayer} och \code{FastOptimalPlayer} ärver från \code{Player} och kommer vilja ha tillgång till denna metod.

\code{Player}s viktiga funktion är dess \code{move}-metod. Det är denna metod som kommer skilja sig för olika players. I den första uppgiften skall ett tal (draget) läsas in i \code{HumanPlayer}s \code{move}-metod, och i nästkommande uppgift skall ett slumpmässigt drag väljas i \code{RandomPlayer}s \code{move}-metod.
Kodskelettet för \code{Player} ser ut på följande sätt:
\begin{ScalaSpec}{Player}
abstract class Player(name: String) {

	/**
	 * Abstract method. Should not be implemented here,
	 * but required by subtypes of Player.
	 * Returns an int p in the interval [0,8] where game(p) == 0,
	 * the index of the move this player does.
	 */
	def move(game: Array[Int], depth: Int): Int;

	/**
	 * Returns true if there exists a row, column or diagonal,
	 * where all the elements are equal to who.
	 */
	def gameWon(game: Array[Int], who: Int): Boolean = ???

	// returns a String with information about the player.
	override def toString(): String = ???
}
\end{ScalaSpec}


\subsection{Obligatoriska uppgifter}

\Task Implementera ett fungerande spel genom att utöka kodskeletten i klasserna \code{Player}, \code{HumanPlayer} och \code{Game}.

\Subtask Implementera metoden \code{gameWon} i klassen \code{Player} som testar huruvida spelaren \code{who} vunnit spelet.

\Subtask Implementera \code{HumanPlayer}s \code{toString}-metod.

\Subtask Implementera \code{HumanPlayer}s \code{move}-metod.

\Subtask Implementera en version av \code{Game}. Börja med att alltid spela ett spel och alltid rita spelplanen. \code{main}, \code{draw} och \code{play} behöver implementeras. All funktionalitet i \code{main} behöver inte finnas ännu.\footnote{Notera att man behöver invertera spelplanen om den ska skickas till spelare två (alternativt låta spelaren hålla reda på om den är \texttt{x} eller \texttt{o}). Förslagsvis löses detta med en extra metod \code{invertGame} som skapar en ny array med omvända tecken till originalarrayen.}

\Task \code{RandomPlayer}

\Subtask Skapa en ny klass som ärver från \code{Player} (kopiera \code{HumanPlayer}, och byt namn till \code{RandomPlayer}) där \code{move} istället för att läsa från \code{System.in} väljer ett slumpmässigt giltigt drag.

\Subtask Ändra \code{Game} så att användaren tillåts stänga av ritfunktionen och i så fall tillåts välja antalet spel.

\Subtask Vad är sannolikheterna för att \texttt{x} vinner, \texttt{o} vinner och att det blir oavgjort om två \code{RandomPlayer}s spelar mot varandra?

Hamnar man i närheten av dessa resultat tror vi på er \code{RandomPlayer}.
\begin{itemize}
	\item P(\texttt{x} vinner) = 0.586
	\item P(\texttt{o} vinner) = 0.288
	\item P(lika) = 0.126
\end{itemize}

\Subtask Varför är det större sannolikhet för \texttt{x} att vinna än \texttt{o}?

\Task \code{OptimalPlayer}

Betrakta den givna funktionen \code{eval}.
\begin{Code}
/**
 * Return 1 if there is a guaranteed strategy for who to win.
 * Return 0 if there is a guaranteed strategy for who to draw.
 * Return -1 if opponent can force a win no matter what who does.
 * This is done by min,max evaluation.
 * Find the move that gives the opponent the worst possible
 * position (min) and return -min, this is our max.
 * depth is the amount of placed cells (!=0) in game.
 * who is 1 if it's this player's turn to make a move,
 * -1 if it's the opponent's turn to make a move.
 * From move, eval should be called with who = -1.
 */
def eval(game: Array[Int], depth: Int, who: Int): Int = {
	if (gameWon(game, -who)) return -1
	if (depth == 9) return 0
	var min = 1
	for (i <- 0 until 9) {
		if (game(i) == 0) {
			game(i) = who
			val score = eval(game, depth + 1, -who)
			if (score < min) {
				min = score
			}
			game(i) = 0
		}
	}
	-min
}
\end{Code}

\code{eval} avgör om du är i en vinnande, förlorande eller oavgjord situation, givet att båda spelare spelar optimalt. Det som nog är svårast att förstå är varför vi returnerar \code{-min} på slutet. \code{min} sparar det sämsta värdet som vår motståndare kan få givet våra möjliga drag. Vi observerar att vi är i precis omvänd situation jämfört med vår motståndare. Om vår motståndare definitivt vinner förlorar vi definitivt, om det blir oavgjort för vår motståndare blir det också oavgjort för oss, och om vår motståndare definitivt förlorar, då vinner vi. Vi representerade ju vinst med 1, oavgjort med 0 och förlust med -1. Det är alltså härifrån minustecknet kommer ifrån. Vill man läsa mer om detta kan man kolla in Wikipedias artikel om minmax-evaluering.\footnote{\url{https://en.wikipedia.org/wiki/Minimax}} Vi tar helt enkelt det draget som är sämst för vår motståndare.

\Subtask Implementera \code{move-metoden} i \code{OptimalPlaye}r genom att anropa \code{eval}.

\Subtask Låt två \code{OptimalPlayer}s spela mot varandra. Det skall alltid bli oavgjort.

\Subtask Testa att spela mot din \code{OptimalPlayer} med en \code{HumanPlayer}. Kan du spela lika? Kan du vinna?

\Subtask Vad händer om du sätter en \code{RandomPlayer} mot \code{OptimalPlayer}? Blir det någonsin oavgjort? Hur ofta? Blir det någon skillnad om man byter vem som får spela först?

\Task Utöka säkerheten och isoleringen av ditt program

I nuläget finns det förmodligen ett problem med din nuvarande implementation, och det är att du skickar iväg en förändringsbar datastruktur till en \code{Player} som utifrån den förändringsbara datan skall göra ett drag. Tänk om en elak programmerare bestämmer sig för att ändra på spelplanen i sin egna players \code{move}-metod. Då skulle man i princip kunna fuska. För att lösa detta kan man från \code{Game} istället för att ge ifrån sig den egna representationen av spelplanen göra en kopia och ge kopian till \code{Player}n.

\Task Snabbare \code{OptimalPlayer}

Om du låter en \code{OptimalPlayer} spela mot en \code{RandomPlayer} 1000 gånger lär det ta ganska lång tid. Det behöver det inte göra. När \code{OptimalPlayer} bestämmer vilket drag den skall göra första gången går den ju igenom alla andra möjliga drag man kan komma till. Det visar sig att det inte finns så många unika spelbräden. Färre än $3^9 < 20000$.

Skapar vi istället en \code{Map} som innehåller ett värde för varje spelbräde kommer vi kunna spela mycket snabbare när vår \code{Map} väl är genererad. Skillnaden i snabbhet för vårt program blir alltså att vi behöver göra ett uppslag i en \code{Map}, jämfört med ungefär $9! > 300000$ funktionsanrop för ett drag på ett tomt spelbräde.

Det räcker med att modifiera evalueringsmetoden något för att bygga \code{Map}en. Anropa sedan denna med ett tomt bräde, så har vi vår \code{Map} och vår optimala spelare är nu supersnabb!

Man får dock vara lite klurig. En \code{Array[Int]} går inte att använda som nyckel i en \code{Map} i Java, då den inte har en implementerad \code{hashCode}-metod. I Scala är det tillåtet, men mappningen kommer att vara på referenslikhet och inte innehållslikhet, vilket vi i det här fallet inte vill. Enklast, som fungerar säkert i både Java och Scala, är att göra om vår array till en sträng genom att lägga värdena i arrayen efter varandra i strängen. Vi kan göra en privat metod \code{hash(Array[Int]): String} som konkatenerar värdena i arrayen. \code{hash([0,0,0,1,1,0,-1,-1,0])} skall alltså returnera \code{"000110-1-10"}.

\Subtask Skapa en ny subklass till \code{Player}: \code{FastOptimalPlayer}.

\Subtask Skapa och implementera en privat metod \code{hash(Array[Int]): String}.

\Subtask Implementera en konstruktor som skapar och genererar en \code{Map}.

En \code{Map} kan initieras på följande vis:
\begin{Code}
val boardCache = scala.collection.mutable.Map.empty[String, Int]
\end{Code}

För att sedan generera vår \code{Map} krävs en metod som motsvarar \code{eval}-metoden i \code{OptimalPlayer}. Denna kan tas rakt av, men med två små modifikationer:
\begin{itemize}
\item Vid start: Om det redan finns ett key-value-par i \code{Map}en: returnera det parets värde.
\item Vid slut: Innan du returnerar måste ett key-value-par läggas in i den \code{Map} som vi genererar.
\end{itemize}
Denna metod bör sedan anropas i slutet av konstruktorn med ett tomt \code{board}.


\Subtask Låt \code{move}-metoden göra ett \code{Map}-uppslag med hjälp av \code{hash}-metoden och din \code{Map}.

\Subtask Testa att låta en \code{FastOptimalPlayer} spela mot en \code{RandomPlayer}. Du märker nog att skapandet av en \code{FastOptimalPlayer} kommer ta lite tid, runt en halv sekund. Sedan skall det dock gå jättesnabbt när spelarna spelar. 100000 spel skall gå utan problem på någon sekund, vilket borde gå på tiotals minuter för den gamla \code{OptimalPlayer}.
