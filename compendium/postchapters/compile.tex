%!TEX encoding = UTF-8 Unicode
%!TEX root = ../compendium1.tex

\chapter{Editera, kompilera och exekvera}\label{appendix:compile}

\section{Vad är en editor?}

En editor används för att redigera programkod. Det finns många olika editorer att välja på. Erfarna utvecklare lägger ofta mycket energi på att lära sig att använda favoriteditorns kortkommandon och specialfunktioner, eftersom detta påverkar stort hur snabbt kodredigeringen kan göras. 

En bra editor har \textbf{syntaxfärgning} för språket du använder, så att olika delar av koden visas i olika färger. Då går det mycket lättare att läsa och hitta i koden. 

Nedan listas några viktiga funktioner som man använder många gånger dagligen när man kodar:

\begin{itemize}
\item \textbf{Navigera}. Det finns flera olika sätt att flytta markören och bläddra genom koden. Alla editorer erbjuder sökmöjligheter, och de flesta editorer har även mer avancerade sökfunktioner där kodmönster kan identifieras och multipla sökträffar markeras över flera kodfiler. 

\item \textbf{Markera}. Att markera kod kan göras på många sätt: med piltangenter+Shift, med olika speciella menyalternativ, med mus + dubbelklick eller trippelklick, etc. I vissa editorer finns även möjlighet att ha multipla markörer så att flera rader kan editeras samtidigt.

\item \textbf{Kopiera}. Genom Copy-Paste slipper du du skriva samma sak många gånger. Kortkommandona Ctrl+C för Copy och Ctrl+V för Paste sitter i fingrarna efter ett tag. Man ska dock vara medveten om att det lätt blir fel när man kopierar en stor del som sedan ska ändras lite; många Copy-Paste-buggar kommer av att man inte är tillräckligt noggrann och ofta är det bättre att skriva från grunden i stället för att kopiera så att du hinner tänka efter medan du skriver.

\item \textbf{Klipp ut}. Genom Ctrl+X för Cut och Ctrl+V för Paste, kan du lätt flytta kod. Att skriva kod är en stegvis process där man gör många förändringar under resans gång för att förbättra och vidareutveckla koden. Att flytta på kod för att skapa en bättre struktur är mycket vanligt.

\item \textbf{Formatering}. Med indragningar, radbrytningar och nästlade block i flera nivåer får koden struktur. Många editorer kan hjälpa till med detta och har speciella kortkommandon för att ändra indragningsnivå inåt eller utåt. 

\item \textbf{Parentesmatchning}. Olika former av parenteser, \code+ ( { [ ) } ] +,  behöver matchas för att koden ska fungera; annars går kompilatorn ofta helt vilse och konstiga felmeddelanden kan peka på helt fel plats i koden. En bra kodeditor kan hjälpa dig att markera vilka parentespar som hör ihop så att du undviker att spendera för mycket tid med att leta efter en parentes som saknas eller står i vägen.
    
\end{itemize}

I en integrerad utvecklingsmiljö, en s.k. IDE, (se appendix \ref{appendix:ide}) finns en inbyggd editor som, tack vare ett mer intimt samarbete med kompilatorn, kan erbjuda ännu fler avancerade funktioner som hjälper dig i kodarbetet. Men även när du lärt dig använda en IDE kommer du fortfarande ha stor nytta av en ''vanlig'' editor. Ofta har man flera terminalfönster igång, tillsammans med flera editorfönster och en IDE. 

\section{Välj editor}\label{appendix:compile:edit}

I tabell \ref{edit:popular-editors} visas en lista med några populära editorer. Det är en stor fördel om din favoriteditor finns på flera plattformar så att du har nytta av dina förvärvade färdigheter när du behöver växla mellan olika operativsystem. 

I denna kurs rekommenderas \textbf{\texttt{atom}}, eftersom den är öppen, gratis och finns för Linux, Windows och Mac, och har bra stöd för Scala. 

Om du jobbar i Linux och hellre vill börja med en enklare editor, kan du prova \texttt{gedit}. När du behöver mer avancerade funktioner kan du gå över till \texttt{atom}. 

Det kan vara bra att lära sig de allra mest basala kommandona (starta, spara, ändra text och avsluta) i editorerna \texttt{vim} och \texttt{nano}, eftersom dessa kan köras direkt i terminalen, även vid fjärrinloggning utan fönstersystem, och finns förinstallerade i de flesta Linux-system.


\begin{table}

\renewcommand{\arraystretch}{1.25}

    \caption{Några populära editorer. I kursen rekommenderas Atom.}
    \label{edit:popular-editors}

\begin{longtable}{@{}r | p{0.75\textwidth}}
\textit{Editor} & \textit{Beskrivning} \\ \hline

Atom & Öppen, fri och gratis. Finns för Linux, Windows, \& Mac. Är förinstallerad på LTH:s Linux-datorer och startas med kommandot \verb+atom+ i ett terminalfönster. Öppenkällkodsprojektet startades av GitHub och har en aktiv gemenskap med många utvecklare. Det finns en uppsjö med användbara plugins som enkelt kan installeras inifrån programmet med hjälp av en inbyggd pakethanterare i vilken du kan söka efter paketet \verb+language-scala+ och klicka ''install'' så får du syntaxfärgning för Scala.
\newline \url{https://atom.io/} \\

Gedit & Öppen, fri och gratis. Lätt att lära men inte så avancerad. Finns för Linux, Windows \& Mac. Är förinstallerad på LTH:s Linux-datorer och startas med kommandot \verb+gedit+ i ett terminalfönster\newline  
 \url{https://wiki.gnome.org/Apps/Gedit} \\

Nano & \TODO \\


Vim & Öppen, fri och gratis. Hög inlärningströskel. Finns för Linux, Windows, \& Mac. Är förinstallerad på LTH:s Linux-datorer och startas med kommandot \verb+vim+ i ett terminalfönster\newline \url{http://www.vim.org/} \\

Emacs & Öppen, fri och gratis. Hög inlärningströskel. Finns för Linux, Windows, \& Mac. Är förinstallerad på LTH:s Linux-datorer och startas med kommandot \verb+emacs+ i ett terminalfönster\newline \url{http://www.gnu.org/software/emacs/} \\

Sublime Text& Sluten källkod. Gratis att prova på, men programmet föreslår då och då att du köper en licens. Finns för Windows, Mac, Linux. \newline
 \url{http://www.sublimetext.com/3} \\


Notepad++ & Öppen, fri och gratis. Finns endast för Windows. \newline \url{https://notepad-plus-plus.org/} \\


Textwrangler & Sluten källkod. Gratis. Lätt att lära men inte så avancerad. Finns endast för Mac.  
\newline \url{http://www.barebones.com/products/textwrangler/} \\

\end{longtable}

\end{table}

\section{Vad är en kompilator?}

En \textbf{kompilator} \Eng{compiler} är ett program som läser programtext och översätter den till exekverbar maskinkod, så som visas i figur \ref{fig:appendix:compiler}. Programtexten som kompileras kallas källkod och utgörs av text som följer reglerna för ett programmeringsspråk, till exempel Scala eller Java. 

\begin{figure}[H]
\centering
\begin{tikzpicture}[node distance=1.8cm, scale=1.5]
\node (input) [startstop] {\bf\sffamily Källkod};
\node(inptext) [right of=input, text width=2cm, xshift=1.5cm]{För\\människor};
\node (compile) [process, below of=input] {\bf\sffamily Kompilator};
%\node(explain) [right of=compile, text width=5cm, xshift=3.0cm]{Översätter från källkod till maskinkod};
\node (output) [startstop, below of=compile] {\bf\sffamily Maskinkod};
\node(outtext) [right of=output, text width=2cm, xshift=1.5cm]{För\\maskiner};
\draw [arrow] (input) -- (compile);
\draw [arrow] (compile) -- (output);
\end{tikzpicture}
    \caption{En kompilator översätter från källkod till maskinkod.}
    \label{fig:appendix:compiler}
\end{figure}




Vissa kompilatorer genererar kod som kan köras av en processor direkt, medan andra kompilatorer genererar ett mellanformat som tolkas under exekveringen. Det senare är fallet med Java och Scala, vilket möjliggör att programmet kan kompileras en gång för alla plattformar och sedan kan programmet köras på all de processorer till vilka det finns en s.k. virtuell maskin för Java \Eng{Java Virtual Machine, JVM}. Den kod som genereras av en kompilator för JVM kallas \textbf{bytekod}.

Om kompileringen inte lyckas skriver kompilatorn ut ett felmeddelande och ingen maskinkod genereras. Det är inte lätt att bygga en kompilator som ger bra felmeddelanden i alla lägen, men felmeddelandet ger oftast goda ledtrådar till felorsaken efter att man lärt sig tolka det programmeringsspråksspecifika vokabulär som kompilatorn använder.

Även om programmet kompilerar utan felmeddelande och genererar exekverbar maskinkod, är det vanligt att programmet ändå inte fungerar som det är tänkt. Ibland är det mycket svårt att lista ut vad problemet beror på och man kan behöva göra omfattande undersökningar av vad som händer under körningen, genom att t.ex. skriva ut olika variablers värden eller på annat sätt ändra koden och se vad som händer. Denna process kallas felsökning eller avlusning \Eng{debugging}, och är en väsentlig del av all systemutveckling. 

En uttömmande testning av ett större program, som kör programmets \textit{alla} möjliga exekveringsvägar, är i praktiken omöjlig att genomföra inom rimlig tid, då antalet kombinationsmöjligheter växer mycket snabbt med storleken på programmet. 
Därför är kompilatorn ett mycket viktigt hjälpmedel. Med hjälp av den analys och de kontroller som görs av kompilatorn kan många buggar, som annars vore mycket svåra att hitta, undvikas och åtgärdas i kompileringsfasen, redan \textit{innan} man exekverar programmet. 


\section{Java JDK}

Scala, Java och flera andra språk använder Java-plattformen som exekveringsmiljö. Om man inte bara vill köra program som andra har utvecklat, utan även utveckla egna program som fungerar i denna miljö, behöver man installera Java Develpment Kit (JDK). Detta utvecklingspaket innehåller flera delar, bland annat:

\begin{itemize}

\item Kompilatorn \texttt{javac} kompilerar Java-program till bytekod som lagras i klassfiler med filnamnsändelsen \texttt{.class}.

\item Exekveringsmiljön Java Runtime Enviroment (JRE) med kommandot \texttt{java} som drar igång den virtuella javamaskinen (Java Virtual Machine) som kan ladda och exekvera bytekod lagrade i klassfiler.

\item Programmet \texttt{jar} som packar ihop många sammanhörande klassfiler till en enda jar-fil som lätt kan distribueras via nätet och sedan köras med \texttt{java}-kommandot på alla maskiner med JRE. 

\item Programmet \texttt{javap} som läser klassfiler och skriver ut vad de innehåller i ett format som kan läsas av människor (ett sådant program kallas disassembler).

\item I JDK ingår också en mycket stor mängd färdiga programbibliotek med stöd för nätverkskommunikation, filhantering, grafik, kryptering och en massa annat som behövs när man bygger moderna system. 

\end{itemize}  

\noindent Du kan läsa mer om Java och dess historik här: \\
\href{https://en.wikipedia.org/wiki/Java_(programming_language)}{https://en.wikipedia.org/wiki/Java\_(programming\_language)}

\subsection{Kontrollera om du har JDK installerat}\label{appendix:compile:check-jdk}

Öppna ett terminalfönster (se appendix \ref{appendix:terminal}) och skriv (observera det avslutande c:et i \texttt{javac}):
\begin{REPLnonum}
javac -version
\end{REPLnonum}
Då ska ungefär följande skrivas ut (där siffran 101 kan vara något annat):
\begin{REPLnonum}
javac 1.8.0_101
\end{REPLnonum}
Om utskriften säger att \texttt{javac} saknas, installera JDK enl. nedan.

Du kanske redan har enbart Java Runtime Environment (JRE) installerad, men inte JDK. Då saknar du Javakompilatorn \texttt{javac} m.m. och behöver installera JDK, se nedan. Du kan kolla om du har JRE genom att skriva \texttt{java -version} (alltså utan \texttt{c} efter \texttt{java}). Eller så har du redan JDK installerad men inte rätt bibliotek i din PATH; se vidare nedan ang. uppdatering av PATH.



\subsection{Installera JDK}\label{appendix:compile:install-jdk}

Det finns flera JDK-distributioner att välja mellan, varav Oracle JDK och Azul Zulu OpenJDK är två exempel. Oracle JDK har störst spridning och är förinstallerad på LTH:s datorer. För att installera JDK på din egen dator behöver du gå igenom flera steg, varav vissa behöver anpassas efter det operativsystem du kör, enligt nedan. 
På kurshemsidan under ''Verktyg'' finns kompletterande instruktioner:  \url{http://cs.lth.se/pgk/verktyg} 


Din användaridentitet behöver ha administratörsrättigheter för att du ska kunna genomföra installationen.



\subsubsection{Linux} 
För Ubuntu: läs igenom och följ sedan dessa instruktioner noga: \\ \href{http://www.webupd8.org/2012/09/install-oracle-java-8-in-ubuntu-via-ppa.html}{www.webupd8.org/2012/09/install-oracle-java-8-in-ubuntu-via-ppa.html}

För andra Linux-distributioner, kör detta i terminalen (funkar även i Ubuntu, men du får med detta kommando inte Oracles aningen snabbare JVM): \\ \texttt{sudo apt-get install openjdk-8-jdk}

\subsubsection{Windows/macOS}

\begin{enumerate}
\item Installera senaste JDK från Oracle. Om du inte har installerat JDK förr på din dator så be gärna någon kurskamrat med erfarenhet av detta att assistera dig medan du följer stegen nedan. 

\begin{enumerate}
\item Surfa till Oracles hemsida för Java SE här: \\ \url{http://www.oracle.com/technetwork/java/javase/downloads/}

\item Klicka på rubriken ''Java SE 8u101 / 8u102'' och på nästa sida klicka på knappen ''Accept License Agreement'' i listan under rubriken ''Java SE Development Kit 8u101''. (Siffrorna 101 eller 102 kan vara annorlunda om senare versioner tillkommit.)

\item Välj rätt version av operativsystem (Windows x64 eller Mac OS X). Det är viktigt att du väljer x64, d.v.s 64-bitarsvarianten som gäller för alla moderna datorer.

\item Klicka på länken och en stor fil kommer laddas ner till din dator.

\item Installera när filen laddats färdigt. 

\end{enumerate}

\item Uppdatera PATH, så att du får tillgång till alla kommando i terminalen:
\begin{itemize}
\item För Windows görs detta enklast genom att ladda ner och sedan köra denna fil genom att dubbelklicka på den: \\ \mbox{\href{https://github.com/lunduniversity/introprog/raw/master/tools/windows-jdk-set-path.bat}{github.com/lunduniversity/introprog/raw/master/tools/windows-jdk-set-path.bat}}
\item För macOS, läs här: \\ \href{https://docs.oracle.com/javase/8/docs/technotes/guides/install/mac_jdk.html}{docs.oracle.com/javase/8/docs/technotes/guides/install/mac\_jdk.html} 
\\ \TODO finn ut bästa rådet att sätta path på mac; homebrew??? 

\item Om något krånglar, be om hjälp. Om du behöver mer detaljer om PATH-uppdatering för java, läs här:  \href{https://java.com/sv/download/help/path.xml}{java.com/sv/download/help/path.xml} \\
Om du kör engelska menyer byt \texttt{sv} mot \texttt{en} i adressen ovan.  Du kan ta reda på vilken katalog som ska läggas in sist i din PATH genom att bläddra bland dina systemfiler och undersöka var JDK har installerats; i Windows antagligen något liknande detta (kolla exakt vilket versionsnummer du har): \code|C:\Program Files\Java\jdk1.8.0_101\bin|
\end{itemize}

\item Starta om datorn. Det är först efter att en ny användarinloggning initierats, som PATH-tilldelningen får effekt.

\item Kontrollera att \texttt{javac} fungerar enligt avsnitt \ref{appendix:compile:check-jdk}.
\end{enumerate}


\section{Scala}

Scala använder JDK som exekveringsmiljö, men erbjuder ytterligare verktyg specifika för Scala. I utvecklingspaketet för Scala ingår bl.a. kompilatorn \texttt{scalac} och även ett interaktivt kommandoskal kallat Scala REPL där du kan testa din Scala-kod rad för rad och se vad som händer direkt. 

De flesta av kursens övningar görs i Scala REPL, medan laborationerna kräver kompilering av lite större program.

Du hittar mer om Scalas historik och annan bakgrundsinformation här:\\\mbox{%
 \href{https://en.wikipedia.org/wiki/Scala_(programming_language)}{en.wikipedia.org/wiki/Scala\_(programming\_language)}
}

\subsection{Installera Scala \TODO{Uppdatera till Scala 2.12 ???}}

Scala finns förinstallerat på LTH:s datorer. Du installerar Scala-kompilatorn och den interaktiva kodexperimentmiljön Scala REPL på din egen dator enligt nedan. 

\begin{enumerate}
\item Kontrollera att du har JDK installerad enligt avsnitt \ref{appendix:compile:check-jdk} och installera vid behov enligt avsnitt \ref{appendix:compile:install-jdk}.
\item Surfa till denna hemsida för nedladdning av Scala 2.11.8: \\ \url{http://scala-lang.org/download/2.11.8.html}
\item Klicka på ''Download'' av den variant som är relevant för ditt operativsystem och spara filen:

\begin{enumerate}
\item \textbf{Linux Ubuntu}: Filen heter \texttt{scala-2.11.8.deb} och installeras genom att dubbelklicka på filen eller via terminalkommandot:\\ \code{sudo apt install ~/Downloads/scala-2.11.8.deb} \\ Anpassa sökvägen ovan efter var du sparade filen. 
\item \textbf{Windows}: Filen heter \texttt{scala-2.11.8.msi} och installationen startas med ett dubbelklick. Följ instruktionerna. Installationsprogrammet uppdaterar även din PATH åt dig och kommandot \texttt{scala} bör fungera efter omstart.
\item \textbf{Mac}: Filen heter \texttt{scala-2.11.8.tgz} och kan packas upp på lämpligt ställe med terminalkommandot \texttt{tar -xvzf scala-2.11.8.tgz} och sedan är det underkatalogen \texttt{bin} som ska inkluderas i din PATH. \TODO klura ut säkraste rådet för PATH-uppdatering på mac -- enklast är nog att visa hur man installerar via homebrew
\end{enumerate}
\end{enumerate}
Kontrollera, efter ev. omstart, att terminalkommandot \texttt{scala} nu kan användas för att starta Scala REPL på din dator:
\begin{REPLnonum}
$ scala
Welcome to Scala 2.11.8 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_101).
Type in expressions for evaluation. Or try :help.

scala> val msg = "hej"
msg: String = hej

scala> println(msg)
hej

scala> 
\end{REPLnonum}
 

\subsection{Scala Read-Evaluate-Print-Loop (REPL)}\label{appendix:compile:REPL}

För många språk, t.ex. Scala och Python, finns det ett interaktivt program ämnat för terminalen som gör det möjligt att exekvera enstaka programrader och direkt se effekten. Ett sådant program kallas \textit{Read-Evaluate-Print-Loop} (REPL), eftersom det läser  och tolkar en rad i taget. Resultatet av evalueringen av din kod skrivs ut i terminalen och därefter är kommandoskalet redo för nästa kodrad.

Kursens övningar bygger till stor del på att du använder Scala REPL för att undersöka principer och begrepp som ingår i kursen genom dina egna kodexperiment. Även när du på labbarna utvecklar större program med en editor och en IDE, är det bra att ha Scala REPL till hands. Då kan du klistra in delar av programmet du håller på att utveckla i Scala REPL och stegvis utveckla delprogram, som till slut fungerar så som du vill. 

I Scala REPL får du se typinformation för variabler och metoder, vilket är till stor hjälp när man försöker lista ut vad en kodrad innebär. Genom att öva upp din förmåga att dra nytta av Scala REPL, kommer din produktivitet öka.

Du startar Scala REPL med kommandot \texttt{scala} och skriver Scala-kod efter prompten \texttt{scala>} och kompilering+exekvering sker när du trycker Enter.
\begin{REPLnonum}
$ scala
Welcome to Scala 2.11.8 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_101).
Type in expressions for evaluation. Or try :help.

scala> def inc(x: Int) = x + 1
inc: (x: Int)Int

scala> inc(inc(inc(1)))
res8: Int = 4

scala> 
\end{REPLnonum}

Med kommandot \texttt{:paste} försätter du Scala REPL i inklistringsläge \Eng{paste mode} och du kan då med Ctrl+V (eller Ctrl+Shift+V, eller eventuellt högerklick med musen, beroende på hur ditt terminalprogram är inställt och vilket operativsystem du kör) klistra in större sjok av kod. När du med Ctrl+D avslutar inklistringsläget tolkar Scala REPL alla raderna på en gång. Kommandot  \texttt{:paste} kan förkortas till  \texttt{:pa}, så som visas nedan. Koden mellan raderna som börjar med \texttt{//} klistrades in av användaren efter att ha kopierats från en editor i ett annat fönster.

\begin{REPLnonum}
scala> :pa
// Entering paste mode (ctrl-D to finish)

case class Point3D(val pos: (Int, Int, Int))
object Point3D {
  def apply(x: Int, y: Int) = new Point3D(x,y,0)
}

// Exiting paste mode, now interpreting.

defined class Point3D
defined object Point3D

scala> Point3D(1,2)
res6: Point3D = Point3D((1,2,0))

scala> 
\end{REPLnonum}

Många av de kortkommandon som fungerar i terminalens kommandoskal, fungerar också i Scala REPL. Gå gärna igenom listan i tabell \ref{fig:terminal:shortcuts} på sidan \pageref{fig:terminal:shortcuts}, och testa vad som händer i Scala REPL. Om du tränar upp din fingerfärdighet med dessa kortkommandon, går ditt arbete i Scala REPL väsentligt snabbare. 

Med kommandot \texttt{:help} får du se en lista med specialkommandon för Scala REPL, inklusive de som återfinns i tabell \ref{fig:repl:shortcuts} på sidan \pageref{fig:repl:shortcuts}.

\begin{table}
\renewcommand{\arraystretch}{1.25}\centering
    \caption{Några vanliga kommandon i Scala REPL.}
    \label{fig:repl:shortcuts}
\begin{tabular}{r | c | l}
\textit{Kommando} & \textit{Förk.} & \textit{Beskrivning} \\ \hline 
 \texttt{:help}     & \texttt{:he} & visa lista med kommando och förklaringar\\
 \texttt{:paste}     & \texttt{:pa} & växla till inklistringsläge \Eng{paste mode}\\
 \texttt{:paste} \textit{path}    & \texttt{:pa} \textit{path} & klistra in en hel fil, t.ex. \code|:pa util/mio.scala|\\
 \texttt{:quit} & \texttt{:q}  & avsluta Scala REPL \\ 
 \texttt{:require} \textit{path} & \texttt{:req} \textit{path} & jar-fil till classpath, t.ex. \texttt{:req lib/cslib.jar}\\
 
 \texttt{:type} & \texttt{:t}  & visa typ med -v för ''verbose'', t.ex. \code|:t -v 42.0| \\ 

 \texttt{:warnings} & \texttt{:w}  & visa beskrivning av ev. varningar \\ 

\end{tabular}

\end{table}





